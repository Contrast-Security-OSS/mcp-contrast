/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.tool.vulnerability;

import com.contrast.labs.ai.mcp.contrast.result.LibraryLibraryObservation;
import com.contrast.labs.ai.mcp.contrast.result.StackLib;
import com.contrast.labs.ai.mcp.contrast.result.Vulnerability;
import com.contrast.labs.ai.mcp.contrast.sdkextension.SDKExtension;
import com.contrast.labs.ai.mcp.contrast.sdkextension.SDKHelper;
import com.contrast.labs.ai.mcp.contrast.sdkextension.data.LibraryExtended;
import com.contrast.labs.ai.mcp.contrast.sdkextension.data.sca.LibraryObservation;
import com.contrast.labs.ai.mcp.contrast.tool.base.SingleTool;
import com.contrast.labs.ai.mcp.contrast.tool.base.SingleToolResponse;
import com.contrast.labs.ai.mcp.contrast.tool.vulnerability.params.GetVulnerabilityParams;
import com.contrastsecurity.http.TraceFilterForm;
import com.contrastsecurity.models.EventResource;
import com.contrastsecurity.models.Stacktrace;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.stereotype.Service;

/**
 * MCP tool for retrieving detailed vulnerability information. Demonstrates the tool-per-class
 * pattern with SingleTool for non-paginated single-item retrieval.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class GetVulnerabilityTool extends SingleTool<GetVulnerabilityParams, Vulnerability> {

  private final VulnerabilityMapper vulnerabilityMapper;

  @Tool(
      name = "get_vulnerability",
      description =
          """
          Get detailed information about a specific vulnerability by ID.

          Returns comprehensive vulnerability data including remediation guidance,
          stack traces, and vulnerable library information when available.

          Response fields:
          - hint: AI-generated remediation hint based on vulnerability type
          - howToFix: Official remediation recommendation from Contrast
          - stackTrace: Stack frames with library hash links (available when trigger events exist)
          - vulnerableLibraries: Libraries in the stack with known CVEs
          - httpRequest: The HTTP request that triggered the vulnerability (if captured)
          - environments: All environments where this vulnerability has been observed

          Usage examples:
          - Get vulnerability details: vulnId="VULN-ABC123", appId="app-123"

          Note: Some fields may be null if data wasn't captured or isn't available.
          Warnings will indicate which optional data couldn't be retrieved.

          Related tools:
          - search_vulnerabilities: Find vulnerability IDs by filtering on severity, status, etc.
          - search_applications: Find application IDs by name or tag
          """)
  public SingleToolResponse<Vulnerability> getVulnerability(
      @ToolParam(description = "Vulnerability ID (use search_vulnerabilities to find)")
          String vulnId,
      @ToolParam(description = "Application ID (use search_applications to find)") String appId) {
    return executePipeline(() -> GetVulnerabilityParams.of(vulnId, appId));
  }

  @Override
  protected Vulnerability doExecute(GetVulnerabilityParams params, List<String> warnings)
      throws Exception {
    var sdk = getContrastSDK();
    var orgId = getOrgId();

    // Fetch trace with expanded data
    var expand =
        EnumSet.of(
            TraceFilterForm.TraceExpandValue.APPLICATION,
            TraceFilterForm.TraceExpandValue.SERVER_ENVIRONMENTS,
            TraceFilterForm.TraceExpandValue.SESSION_METADATA);

    var trace = sdk.getTrace(orgId, params.appId(), params.vulnId(), expand);

    if (trace == null) {
      return null; // SingleTool converts this to notFound response
    }

    log.debug("Found trace with title: {} and rule: {}", trace.getTitle(), trace.getRule());

    // Build context with graceful degradation - fetch optional data
    var context = buildVulnerabilityContext(sdk, params.vulnId(), params.appId(), orgId, warnings);

    return vulnerabilityMapper.toFullVulnerability(trace, context);
  }

  private VulnerabilityContext buildVulnerabilityContext(
      com.contrastsecurity.sdk.ContrastSDK sdk,
      String vulnId,
      String appId,
      String orgId,
      List<String> warnings) {

    String recommendationText = null;
    String httpRequestText = null;
    var stackLibs = new ArrayList<StackLib>();
    var libsToReturn = new HashSet<LibraryExtended>();

    // Fetch recommendation (optional)
    try {
      var recommendationResponse = sdk.getRecommendation(orgId, vulnId);
      if (recommendationResponse != null && recommendationResponse.getRecommendation() != null) {
        recommendationText = recommendationResponse.getRecommendation().getText();
      }
    } catch (Exception e) {
      log.debug("Could not fetch recommendation for {}: {}", vulnId, e.getMessage());
      warnings.add("Recommendation data not available: " + e.getMessage());
    }

    // Fetch HTTP request (optional)
    try {
      var requestResponse = sdk.getHttpRequest(orgId, vulnId);
      if (requestResponse != null && requestResponse.getHttpRequest() != null) {
        httpRequestText = requestResponse.getHttpRequest().getText();
      }
    } catch (Exception e) {
      log.debug("Could not fetch HTTP request for {}: {}", vulnId, e.getMessage());
      warnings.add("HTTP request data not available: " + e.getMessage());
    }

    // Fetch stack traces and library data (optional)
    try {
      buildStackTraceAndLibraryData(sdk, vulnId, appId, orgId, stackLibs, libsToReturn, warnings);
    } catch (Exception e) {
      log.debug("Could not fetch stack trace data for {}: {}", vulnId, e.getMessage());
      warnings.add("Stack trace data not available: " + e.getMessage());
    }

    return VulnerabilityContext.builder()
        .recommendation(recommendationText)
        .stackLibs(stackLibs)
        .libraries(new ArrayList<>(libsToReturn))
        .httpRequest(httpRequestText)
        .build();
  }

  private void buildStackTraceAndLibraryData(
      com.contrastsecurity.sdk.ContrastSDK sdk,
      String vulnId,
      String appId,
      String orgId,
      List<StackLib> stackLibs,
      HashSet<LibraryExtended> libsToReturn,
      List<String> warnings)
      throws Exception {

    var eventSummaryResponse = sdk.getEventSummary(orgId, vulnId);
    if (eventSummaryResponse == null || eventSummaryResponse.getEvents() == null) {
      return;
    }

    var triggerEvent =
        eventSummaryResponse.getEvents().stream()
            .filter(e -> e.getType().equalsIgnoreCase("trigger"))
            .findFirst();

    if (triggerEvent.isEmpty()) {
      return;
    }

    var stackTraces = extractStackTraces(triggerEvent.get());
    if (stackTraces.isEmpty()) {
      return;
    }

    // Fetch libraries and match to stack frames
    var extendedSDK = getSDKExtension();
    var libs = SDKHelper.getLibsForID(appId, orgId, extendedSDK);
    var lobs = buildLibraryObservations(libs, appId, orgId, extendedSDK);

    for (String stackTrace : stackTraces) {
      var matchingLlobOpt = findMatchingLibraryData(stackTrace, lobs);
      if (matchingLlobOpt.isPresent()) {
        var llob = matchingLlobOpt.get();
        var library = llob.library();
        if (!library.getVulnerabilities().isEmpty()) {
          libsToReturn.add(library);
          stackLibs.add(new StackLib(stackTrace, library.getHash()));
        } else {
          stackLibs.add(new StackLib(stackTrace, null));
        }
      } else {
        stackLibs.add(new StackLib(stackTrace, null));
      }
    }
  }

  private List<String> extractStackTraces(EventResource triggerEvent) {
    var stackTraces = new ArrayList<String>();
    var sTrace = triggerEvent.getEvent().getStacktraces();
    if (sTrace != null) {
      stackTraces.addAll(sTrace.stream().map(Stacktrace::getDescription).toList());
    }
    return stackTraces;
  }

  private List<LibraryLibraryObservation> buildLibraryObservations(
      List<LibraryExtended> libs, String appId, String orgId, SDKExtension extendedSDK)
      throws Exception {
    var lobs = new ArrayList<LibraryLibraryObservation>();
    for (LibraryExtended lib : libs) {
      var observations =
          SDKHelper.getLibraryObservationsWithCache(lib.getHash(), appId, orgId, 50, extendedSDK);
      lobs.add(new LibraryLibraryObservation(lib, observations));
    }
    return lobs;
  }

  private Optional<LibraryLibraryObservation> findMatchingLibraryData(
      String stackTrace, List<LibraryLibraryObservation> lobs) {
    var lowerStackTrace = stackTrace.toLowerCase();
    for (LibraryLibraryObservation llob : lobs) {
      for (LibraryObservation lob : llob.libraryObservation()) {
        if (lob.getName() != null && lowerStackTrace.startsWith(lob.getName().toLowerCase())) {
          return Optional.of(llob);
        }
      }
    }
    return Optional.empty();
  }
}
