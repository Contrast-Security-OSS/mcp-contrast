/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast;

import com.contrastsecurity.http.RuleSeverity;
import com.contrastsecurity.http.ServerEnvironment;
import com.contrastsecurity.http.TraceFilterForm;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

/**
 * Vulnerability filter parameters with validation and SDK conversion.
 * Hard failures (errors) stop execution. Soft failures (warnings) continue with corrected values.
 *
 * @param form SDK TraceFilterForm with all filters applied
 * @param appId Application ID for routing decision (null = org-level query)
 * @param warnings Validation warnings (soft failures - execution continues)
 * @param errors Validation errors (hard failures - execution must stop)
 */
public record VulnerabilityFilterParams(
    TraceFilterForm form,
    String appId,
    List<String> warnings,
    List<String> errors
) {
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityFilterParams.class);

    // Valid status values for validation
    private static final Set<String> VALID_STATUSES = Set.of(
        "Reported", "Suspicious", "Confirmed", "Remediated", "Fixed"
    );

    /**
     * Parse and validate vulnerability filter parameters.
     * Returns object with validation status (warnings/errors) and configured TraceFilterForm.
     *
     * @param severities Comma-separated severity levels (e.g., "CRITICAL,HIGH")
     * @param statuses Comma-separated statuses (e.g., "Reported,Confirmed"), null = smart defaults
     * @param appId Application ID for filtering (null = all apps)
     * @param vulnTypes Comma-separated vulnerability types (e.g., "sql-injection,xss-reflected")
     * @param environments Comma-separated environments (e.g., "PRODUCTION,QA")
     * @param lastSeenAfter ISO date or epoch timestamp (e.g., "2025-01-01")
     * @param lastSeenBefore ISO date or epoch timestamp
     * @param vulnTags Comma-separated vulnerability tags (e.g., "SmartFix Remediated,reviewed")
     * @return VulnerabilityFilterParams with validated filters and feedback messages
     */
    public static VulnerabilityFilterParams of(
            String severities,
            String statuses,
            String appId,
            String vulnTypes,
            String environments,
            String lastSeenAfter,
            String lastSeenBefore,
            String vulnTags
    ) {
        List<String> warnings = new ArrayList<>();
        List<String> errors = new ArrayList<>();
        TraceFilterForm form = new TraceFilterForm();

        // Parse severity filter (HARD FAILURE - all invalid values are errors)
        if (severities != null && !severities.trim().isEmpty()) {
            List<String> severityList = FilterHelper.parseCommaSeparatedUpperCase(severities);
            if (severityList != null && !severityList.isEmpty()) {
                EnumSet<RuleSeverity> severitySet = EnumSet.noneOf(RuleSeverity.class);
                for (String sev : severityList) {
                    try {
                        severitySet.add(RuleSeverity.valueOf(sev));
                    } catch (IllegalArgumentException e) {
                        logger.warn("Invalid severity value: {}", sev);
                        errors.add(String.format(
                            "Invalid severity '%s'. Valid: CRITICAL, HIGH, MEDIUM, LOW, NOTE. Example: 'CRITICAL,HIGH'",
                            sev
                        ));
                    }
                }
                if (!severitySet.isEmpty() && errors.isEmpty()) {
                    form.setSeverities(severitySet);
                }
            }
        }

        // Parse status filter with smart defaults (HARD FAILURE - invalid status values are errors)
        List<String> statusList;
        boolean usingSmartDefaults = false;
        if (statuses == null || statuses.trim().isEmpty()) {
            // Smart defaults: exclude Fixed and Remediated
            statusList = Arrays.asList("Reported", "Suspicious", "Confirmed");
            usingSmartDefaults = true;
            logger.debug("Using smart defaults for status filter: {}", statusList);
        } else {
            statusList = FilterHelper.parseCommaSeparated(statuses);
            // Validate each status value
            if (statusList != null) {
                for (String status : statusList) {
                    if (!VALID_STATUSES.contains(status)) {
                        errors.add(String.format(
                            "Invalid status '%s'. Valid: Reported, Suspicious, Confirmed, Remediated, Fixed. Example: 'Reported,Confirmed'",
                            status
                        ));
                    }
                }
            }
        }
        if (statusList != null && !statusList.isEmpty() && errors.isEmpty()) {
            form.setStatus(statusList);
            if (usingSmartDefaults) {
                warnings.add(
                    "Showing actionable vulnerabilities only (excluding Fixed and Remediated). " +
                    "To see all statuses, specify statuses parameter explicitly."
                );
            }
        }

        // Parse vulnerability type filter (no validation - pass through)
        if (vulnTypes != null && !vulnTypes.trim().isEmpty()) {
            List<String> vulnTypeList = FilterHelper.parseCommaSeparatedLowerCase(vulnTypes);
            if (vulnTypeList != null && !vulnTypeList.isEmpty()) {
                form.setVulnTypes(vulnTypeList);
            }
        }

        // Parse environment filter (HARD FAILURE - all invalid values are errors)
        if (environments != null && !environments.trim().isEmpty()) {
            List<String> envList = FilterHelper.parseCommaSeparatedUpperCase(environments);
            if (envList != null && !envList.isEmpty()) {
                EnumSet<ServerEnvironment> envSet = EnumSet.noneOf(ServerEnvironment.class);
                for (String env : envList) {
                    try {
                        envSet.add(ServerEnvironment.valueOf(env));
                    } catch (IllegalArgumentException e) {
                        logger.warn("Invalid environment value: {}", env);
                        errors.add(String.format(
                            "Invalid environment '%s'. Valid: DEVELOPMENT, QA, PRODUCTION. Example: 'PRODUCTION,QA'",
                            env
                        ));
                    }
                }
                if (!envSet.isEmpty() && errors.isEmpty()) {
                    form.setEnvironments(envSet);
                }
            }
        }

        // Parse date filters (HARD FAILURE - unparseable dates are errors)
        Date startDate = null;
        Date endDate = null;

        if (lastSeenAfter != null && !lastSeenAfter.trim().isEmpty()) {
            FilterHelper.ParseResult<Date> result =
                FilterHelper.parseDateWithValidation(lastSeenAfter, "lastSeenAfter");
            if (result.hasValidationMessage()) {
                // Hard failure - cannot parse date
                errors.add(result.getValidationMessage());
            } else if (result.getValue() != null) {
                startDate = result.getValue();
                form.setStartDate(startDate);
            }
        }

        if (lastSeenBefore != null && !lastSeenBefore.trim().isEmpty()) {
            FilterHelper.ParseResult<Date> result =
                FilterHelper.parseDateWithValidation(lastSeenBefore, "lastSeenBefore");
            if (result.hasValidationMessage()) {
                // Hard failure - cannot parse date
                errors.add(result.getValidationMessage());
            } else if (result.getValue() != null) {
                endDate = result.getValue();
                form.setEndDate(endDate);
            }
        }

        // Add time filter note if at least one date filter was successfully applied
        if ((startDate != null || endDate != null) && errors.isEmpty()) {
            warnings.add("Time filters apply to LAST ACTIVITY DATE (lastTimeSeen), not discovery date.");
        }

        // Validate date range (HARD FAILURE - logical contradiction)
        if (startDate != null && endDate != null && startDate.after(endDate)) {
            errors.add(
                "Invalid date range: lastSeenAfter must be before lastSeenBefore. " +
                "Example: lastSeenAfter='2025-01-01', lastSeenBefore='2025-12-31'"
            );
        }

        // Parse vulnerability tags filter (no validation - pass through, case-sensitive)
        // SDK now properly handles URL encoding of filterTags (AIML-193 complete)
        if (vulnTags != null && !vulnTags.trim().isEmpty()) {
            List<String> vulnTagList = FilterHelper.parseCommaSeparated(vulnTags);
            if (vulnTagList != null && !vulnTagList.isEmpty()) {
                form.setFilterTags(vulnTagList);
            }
        }

        return new VulnerabilityFilterParams(
            form,
            appId,
            List.copyOf(warnings),
            List.copyOf(errors)
        );
    }

    /**
     * Returns true if filters are valid enough to execute query.
     * Check errors() for details if false.
     *
     * @return true if no errors, false if errors exist
     */
    public boolean isValid() {
        return errors.isEmpty();
    }

    /**
     * Convert to SDK TraceFilterForm.
     * Explicitly marks SDK boundary crossing.
     *
     * @return TraceFilterForm configured with all filters
     */
    public TraceFilterForm toTraceFilterForm() {
        return form;
    }
}
