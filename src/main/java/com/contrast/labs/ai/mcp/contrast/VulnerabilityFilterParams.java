/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast;

import com.contrastsecurity.http.RuleSeverity;
import com.contrastsecurity.http.ServerEnvironment;
import com.contrastsecurity.http.TraceFilterForm;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Vulnerability filter parameters with validation and SDK conversion. Hard failures (errors) stop
 * execution. Soft failures (warnings) continue with corrected values.
 *
 * @param form SDK TraceFilterForm with all filters applied
 * @param appId Application ID for routing decision (null = org-level query)
 * @param warnings Validation warnings (soft failures - execution continues)
 * @param errors Validation errors (hard failures - execution must stop)
 */
public record VulnerabilityFilterParams(
    TraceFilterForm form, String appId, List<String> warnings, List<String> errors) {
  private static final Logger logger = LoggerFactory.getLogger(VulnerabilityFilterParams.class);

  // Valid status values for validation
  private static final Set<String> VALID_STATUSES =
      Set.of("Reported", "Suspicious", "Confirmed", "Remediated", "Fixed");

  /**
   * Parse and validate vulnerability filter parameters. Returns object with validation status
   * (warnings/errors) and configured TraceFilterForm.
   *
   * @param severities Comma-separated severity levels (e.g., "CRITICAL,HIGH")
   * @param statuses Comma-separated statuses (e.g., "Reported,Confirmed"), null = smart defaults
   * @param appId Application ID for filtering (null = all apps)
   * @param vulnTypes Comma-separated vulnerability types (e.g., "sql-injection,xss-reflected")
   * @param environments Comma-separated environments (e.g., "PRODUCTION,QA")
   * @param lastSeenAfter ISO date or epoch timestamp (e.g., "2025-01-01")
   * @param lastSeenBefore ISO date or epoch timestamp
   * @param vulnTags Comma-separated vulnerability tags (e.g., "SmartFix Remediated,reviewed")
   * @return VulnerabilityFilterParams with validated filters and feedback messages
   */
  public static VulnerabilityFilterParams of(
      String severities,
      String statuses,
      String appId,
      String vulnTypes,
      String environments,
      String lastSeenAfter,
      String lastSeenBefore,
      String vulnTags) {
    List<String> warnings = new ArrayList<>();
    List<String> errors = new ArrayList<>();
    TraceFilterForm form = new TraceFilterForm();

    // Parse severity filter (HARD FAILURE - all invalid values are errors)
    if (severities != null && !severities.trim().isEmpty()) {
      List<String> severityList = FilterHelper.parseCommaSeparatedUpperCase(severities);
      if (severityList != null && !severityList.isEmpty()) {
        EnumSet<RuleSeverity> severitySet = EnumSet.noneOf(RuleSeverity.class);
        for (String sev : severityList) {
          try {
            severitySet.add(RuleSeverity.valueOf(sev));
          } catch (IllegalArgumentException e) {
            logger.warn("Invalid severity value: {}", sev);
            errors.add(
                String.format(
                    "Invalid severity '%s'. Valid: CRITICAL, HIGH, MEDIUM, LOW, NOTE. Example:"
                        + " 'CRITICAL,HIGH'",
                    sev));
          }
        }
        if (!severitySet.isEmpty() && errors.isEmpty()) {
          form.setSeverities(severitySet);
        }
      }
    }

    // Parse status filter with smart defaults (HARD FAILURE - invalid status values are errors)
    List<String> statusList;
    boolean usingSmartDefaults = false;
    if (statuses == null || statuses.trim().isEmpty()) {
      // Smart defaults: exclude Fixed and Remediated
      statusList = Arrays.asList("Reported", "Suspicious", "Confirmed");
      usingSmartDefaults = true;
      logger.debug("Using smart defaults for status filter: {}", statusList);
    } else {
      statusList = FilterHelper.parseCommaSeparated(statuses);
      // Validate each status value
      if (statusList != null) {
        for (String status : statusList) {
          if (!VALID_STATUSES.contains(status)) {
            errors.add(
                String.format(
                    "Invalid status '%s'. Valid: Reported, Suspicious, Confirmed, Remediated,"
                        + " Fixed. Example: 'Reported,Confirmed'",
                    status));
          }
        }
      }
    }
    if (statusList != null && !statusList.isEmpty() && errors.isEmpty()) {
      form.setStatus(statusList);
      if (usingSmartDefaults) {
        warnings.add(
            "Showing actionable vulnerabilities only (excluding Fixed and Remediated). "
                + "To see all statuses, specify statuses parameter explicitly.");
      }
    }

    // Parse vulnerability type filter (no validation - pass through)
    if (vulnTypes != null && !vulnTypes.trim().isEmpty()) {
      List<String> vulnTypeList = FilterHelper.parseCommaSeparatedLowerCase(vulnTypes);
      if (vulnTypeList != null && !vulnTypeList.isEmpty()) {
        form.setVulnTypes(vulnTypeList);
      }
    }

    // Parse environment filter (HARD FAILURE - all invalid values are errors)
    if (environments != null && !environments.trim().isEmpty()) {
      List<String> envList = FilterHelper.parseCommaSeparatedUpperCase(environments);
      if (envList != null && !envList.isEmpty()) {
        EnumSet<ServerEnvironment> envSet = EnumSet.noneOf(ServerEnvironment.class);
        for (String env : envList) {
          try {
            envSet.add(ServerEnvironment.valueOf(env));
          } catch (IllegalArgumentException e) {
            logger.warn("Invalid environment value: {}", env);
            errors.add(
                String.format(
                    "Invalid environment '%s'. Valid: DEVELOPMENT, QA, PRODUCTION. Example:"
                        + " 'PRODUCTION,QA'",
                    env));
          }
        }
        if (!envSet.isEmpty() && errors.isEmpty()) {
          form.setEnvironments(envSet);
        }
      }
    }

    // Parse date filters (HARD FAILURE - unparseable dates are errors)
    Date startDate = null;
    Date endDate = null;

    if (lastSeenAfter != null && !lastSeenAfter.trim().isEmpty()) {
      FilterHelper.ParseResult<Date> result =
          FilterHelper.parseDateWithValidation(lastSeenAfter, "lastSeenAfter");
      if (result.hasValidationMessage()) {
        // Hard failure - cannot parse date
        errors.add(result.getValidationMessage());
      } else if (result.getValue() != null) {
        startDate = result.getValue();
        form.setStartDate(startDate);
      }
    }

    if (lastSeenBefore != null && !lastSeenBefore.trim().isEmpty()) {
      FilterHelper.ParseResult<Date> result =
          FilterHelper.parseDateWithValidation(lastSeenBefore, "lastSeenBefore");
      if (result.hasValidationMessage()) {
        // Hard failure - cannot parse date
        errors.add(result.getValidationMessage());
      } else if (result.getValue() != null) {
        endDate = result.getValue();
        form.setEndDate(endDate);
      }
    }

    // Add time filter note if at least one date filter was successfully applied
    if ((startDate != null || endDate != null) && errors.isEmpty()) {
      warnings.add("Time filters apply to LAST ACTIVITY DATE (lastTimeSeen), not discovery date.");
    }

    // Validate date range (HARD FAILURE - logical contradiction)
    if (startDate != null && endDate != null && startDate.after(endDate)) {
      errors.add(
          "Invalid date range: lastSeenAfter must be before lastSeenBefore. "
              + "Example: lastSeenAfter='2025-01-01', lastSeenBefore='2025-12-31'");
    }

    // Parse vulnerability tags filter (no validation - pass through, case-sensitive)
    // SDK now properly handles URL encoding of filterTags (AIML-193 complete)
    if (vulnTags != null && !vulnTags.trim().isEmpty()) {
      List<String> vulnTagList = FilterHelper.parseCommaSeparated(vulnTags);
      if (vulnTagList != null && !vulnTagList.isEmpty()) {
        form.setFilterTags(vulnTagList);
      }
    }

    return new VulnerabilityFilterParams(form, appId, List.copyOf(warnings), List.copyOf(errors));
  }

  /**
   * Returns true if filters are valid enough to execute query. Check errors() for details if false.
   *
   * @return true if no errors, false if errors exist
   */
  public boolean isValid() {
    return errors.isEmpty();
  }

  /**
   * Convert to SDK TraceFilterForm. Explicitly marks SDK boundary crossing.
   *
   * @return TraceFilterForm configured with all filters
   */
  public TraceFilterForm toTraceFilterForm() {
    return form;
  }
}
