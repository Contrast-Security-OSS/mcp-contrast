/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.tool.vulnerability.params;

import com.contrast.labs.ai.mcp.contrast.sdkextension.ExtendedTraceFilterBody;
import com.contrast.labs.ai.mcp.contrast.tool.base.BaseToolParams;
import com.contrast.labs.ai.mcp.contrast.tool.validation.ToolValidationContext;
import com.contrast.labs.ai.mcp.contrast.tool.validation.UnresolvedMetadataFilter;
import com.contrast.labs.ai.mcp.contrast.tool.validation.ValidationConstants;
import com.contrastsecurity.http.RuleSeverity;
import com.contrastsecurity.http.ServerEnvironment;
import com.contrastsecurity.models.TraceTimestampField;
import java.util.Date;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;
import org.springframework.util.StringUtils;

/**
 * Validation parameters for SearchAppVulnerabilitiesTool. Extends VulnerabilityFilterParams
 * functionality with application-scoped and session filtering capabilities.
 *
 * <p>Usage:
 *
 * <pre>{@code
 * var params = SearchAppVulnerabilitiesParams.of(
 *     "app-123", "CRITICAL", null, null, null, null, null, null,
 *     "{\"branch\":\"main\"}", false);
 * if (!params.isValid()) {
 *   // Handle errors
 * }
 * var filterBody = params.toTraceFilterBody();
 * }</pre>
 */
public class SearchAppVulnerabilitiesParams extends BaseToolParams {

  private String appId;
  private EnumSet<RuleSeverity> severities;
  private List<String> statuses;
  private List<String> vulnTypes;
  private EnumSet<ServerEnvironment> environments;
  private Date lastSeenAfter;
  private Date lastSeenBefore;
  private List<String> vulnTags;
  private List<UnresolvedMetadataFilter> sessionMetadataFilters;
  private Boolean useLatestSession;

  /** Private constructor - use static factory method {@link #of}. */
  private SearchAppVulnerabilitiesParams() {}

  /**
   * Parse and validate application vulnerability search parameters.
   *
   * @param appIdParam Application ID (required)
   * @param severitiesParam Comma-separated severities (CRITICAL,HIGH,MEDIUM,LOW,NOTE)
   * @param statusesParam Comma-separated statuses (Reported,Suspicious,Confirmed,Remediated,Fixed)
   * @param vulnTypesParam Comma-separated vulnerability types
   * @param environmentsParam Comma-separated environments (DEVELOPMENT,QA,PRODUCTION)
   * @param lastSeenAfterParam ISO date (YYYY-MM-DD) or epoch timestamp
   * @param lastSeenBeforeParam ISO date (YYYY-MM-DD) or epoch timestamp
   * @param vulnTagsParam Comma-separated vulnerability tags
   * @param sessionMetadataFiltersParam JSON object mapping field names to values for session
   *     filtering (e.g., {"branch":"main","developer":["Ellen","Sam"]})
   * @param useLatestSessionParam Filter to latest session only
   * @return SearchAppVulnerabilitiesParams with validation state
   */
  public static SearchAppVulnerabilitiesParams of(
      String appIdParam,
      String severitiesParam,
      String statusesParam,
      String vulnTypesParam,
      String environmentsParam,
      String lastSeenAfterParam,
      String lastSeenBeforeParam,
      String vulnTagsParam,
      String sessionMetadataFiltersParam,
      Boolean useLatestSessionParam) {

    var params = new SearchAppVulnerabilitiesParams();
    var ctx = new ToolValidationContext();

    // Required field
    ctx.require(appIdParam, "appId");
    params.appId = appIdParam;

    // Parse filter parameters with fluent API
    params.severities = ctx.enumSetParam(severitiesParam, RuleSeverity.class, "severities").get();

    params.statuses =
        ctx.stringListParam(statusesParam, "statuses")
            .allowedValues(ValidationConstants.VALID_VULN_STATUSES)
            .defaultTo(
                ValidationConstants.DEFAULT_VULN_STATUSES,
                "Showing actionable vulnerabilities only (excluding Fixed and Remediated). "
                    + "To see all statuses, specify statuses parameter explicitly.")
            .get();

    params.vulnTypes = ctx.stringListParam(vulnTypesParam, "vulnTypes").get();

    params.environments =
        ctx.enumSetParam(environmentsParam, ServerEnvironment.class, "environments").get();

    params.lastSeenAfter = ctx.dateParam(lastSeenAfterParam, "lastSeenAfter").get();
    params.lastSeenBefore = ctx.dateParam(lastSeenBeforeParam, "lastSeenBefore").get();
    ctx.validateDateRange(
        params.lastSeenAfter, params.lastSeenBefore, "lastSeenAfter", "lastSeenBefore");

    // Add time filter note if dates were specified
    if (params.lastSeenAfter != null || params.lastSeenBefore != null) {
      ctx.warnIf(
          true, "Time filters apply to LAST ACTIVITY DATE (lastTimeSeen), not discovery date.");
    }

    params.vulnTags = ctx.stringListParam(vulnTagsParam, "vulnTags").get();

    // Session filtering parameters
    params.sessionMetadataFilters =
        ctx.metadataJsonFilterParam(sessionMetadataFiltersParam, "sessionMetadataFilters").get();
    params.useLatestSession = useLatestSessionParam;

    // Validate useLatestSession and sessionMetadataFilters are mutually exclusive
    ctx.mutuallyExclusive(
        useLatestSessionParam != null && useLatestSessionParam,
        "useLatestSession",
        StringUtils.hasText(sessionMetadataFiltersParam),
        "sessionMetadataFilters",
        "Both define which session to filter by");

    params.setValidationResult(ctx);
    return params;
  }

  /**
   * Convert to ExtendedTraceFilterBody for POST endpoint API calls.
   *
   * @return ExtendedTraceFilterBody configured with all filters including status
   */
  public ExtendedTraceFilterBody toTraceFilterBody() {
    var body = new ExtendedTraceFilterBody();
    // Note: tracked/untracked NOT set - primitive defaults (false) mean "return all"
    if (severities != null) {
      body.setSeverities(severities.stream().toList());
    }
    if (statuses != null) {
      body.setStatus(Set.copyOf(statuses));
    }
    if (vulnTypes != null) {
      body.setVulnTypes(vulnTypes);
    }
    if (environments != null) {
      body.setEnvironments(environments.stream().toList());
    }
    if (lastSeenAfter != null || lastSeenBefore != null) {
      body.setTimestampFilter(TraceTimestampField.LAST);
    }
    if (lastSeenAfter != null) {
      body.setStartDate(lastSeenAfter);
    }
    if (lastSeenBefore != null) {
      body.setEndDate(lastSeenBefore);
    }
    if (vulnTags != null) {
      body.setFilterTags(vulnTags);
    }
    return body;
  }

  public String appId() {
    return appId;
  }

  public EnumSet<RuleSeverity> getSeverities() {
    return severities;
  }

  public List<String> getStatuses() {
    return statuses;
  }

  public List<String> getVulnTypes() {
    return vulnTypes;
  }

  public EnumSet<ServerEnvironment> getEnvironments() {
    return environments;
  }

  public Date getLastSeenAfter() {
    return lastSeenAfter;
  }

  public Date getLastSeenBefore() {
    return lastSeenBefore;
  }

  public List<String> getVulnTags() {
    return vulnTags;
  }

  public List<UnresolvedMetadataFilter> getSessionMetadataFilters() {
    return sessionMetadataFilters;
  }

  public Boolean getUseLatestSession() {
    return useLatestSession;
  }
}
