/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.tool.vulnerability;

import com.contrast.labs.ai.mcp.contrast.PaginationParams;
import com.contrast.labs.ai.mcp.contrast.data.VulnLight;
import com.contrast.labs.ai.mcp.contrast.mapper.VulnerabilityMapper;
import com.contrast.labs.ai.mcp.contrast.sdkextension.SDKExtension;
import com.contrast.labs.ai.mcp.contrast.tool.base.ExecutionResult;
import com.contrast.labs.ai.mcp.contrast.tool.base.PaginatedTool;
import com.contrast.labs.ai.mcp.contrast.tool.base.PaginatedToolResponse;
import com.contrast.labs.ai.mcp.contrast.tool.validation.UnresolvedMetadataFilter;
import com.contrast.labs.ai.mcp.contrast.tool.vulnerability.params.SearchAppVulnerabilitiesParams;
import com.contrastsecurity.http.TraceFilterForm.TraceExpandValue;
import com.contrastsecurity.models.TraceMetadataFilter;
import com.contrastsecurity.sdk.ContrastSDK;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.stereotype.Service;

/**
 * MCP tool for searching vulnerabilities within a specific application. Supports session metadata
 * filtering and latest session filtering in addition to standard vulnerability filters.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class SearchAppVulnerabilitiesTool
    extends PaginatedTool<SearchAppVulnerabilitiesParams, VulnLight> {

  private final VulnerabilityMapper vulnerabilityMapper;

  @Tool(
      name = "search_app_vulnerabilities",
      description =
          """
          Application-scoped vulnerability search with all filters plus session-based filtering.

          Required: appId parameter. Use search_applications tool to find application IDs by name.

          Session filtering (mutually exclusive - choose ONE):
          - sessionMetadataFilters: JSON object for filtering by session metadata
            - AND across fields: {"developer":"Ellen","commit":"100"}
            - OR for multiple values within a field: {"developer":["Ellen","Sam"]}
            - Combined: {"developer":["Ellen","Sam"],"branch":"main"}
          - useLatestSession=true: Filter to the most recent session only

          Note: useLatestSession and sessionMetadataFilters are mutually exclusive.
          If useLatestSession=true and no sessions exist, returns all vulnerabilities
          for the application with a warning message.

          Common usage examples:
          - All vulns in app: appId="abc123"
          - Latest session vulns: appId="abc123", useLatestSession=true
          - Single metadata filter: appId="abc123", sessionMetadataFilters='{"branch":"main"}'
          - Multiple filters (AND): appId="abc123", sessionMetadataFilters='{"branch":"main","developer":"Ellen"}'
          - Multiple values (OR): appId="abc123", sessionMetadataFilters='{"developer":["Ellen","Sam"]}'
          - Production critical: appId="abc123", severities="CRITICAL", environments="PRODUCTION"
          """)
  public PaginatedToolResponse<VulnLight> searchAppVulnerabilities(
      @ToolParam(
              description =
                  "Application ID (required). Use search_applications to find app IDs by name.")
          String appId,
      @ToolParam(description = "Page number (1-based), default: 1", required = false) Integer page,
      @ToolParam(description = "Items per page (max 100), default: 50", required = false)
          Integer pageSize,
      @ToolParam(
              description = "Comma-separated severities: CRITICAL,HIGH,MEDIUM,LOW,NOTE",
              required = false)
          String severities,
      @ToolParam(
              description =
                  "Comma-separated statuses: Reported,Suspicious,Confirmed,Remediated,Fixed."
                      + " Default: Reported,Suspicious,Confirmed",
              required = false)
          String statuses,
      @ToolParam(
              description =
                  "Comma-separated vulnerability types. Use list_vulnerability_types for complete"
                      + " list",
              required = false)
          String vulnTypes,
      @ToolParam(
              description = "Comma-separated environments: DEVELOPMENT,QA,PRODUCTION",
              required = false)
          String environments,
      @ToolParam(
              description =
                  "Only include vulnerabilities with LAST ACTIVITY after this date (ISO: YYYY-MM-DD"
                      + " or epoch)",
              required = false)
          String lastSeenAfter,
      @ToolParam(
              description =
                  "Only include vulnerabilities with LAST ACTIVITY before this date (ISO:"
                      + " YYYY-MM-DD or epoch)",
              required = false)
          String lastSeenBefore,
      @ToolParam(description = "Comma-separated vulnerability tags", required = false)
          String vulnTags,
      @ToolParam(
              description =
                  "JSON object for session metadata filters. Format: {\"fieldName\":\"value\"} or"
                      + " {\"fieldName\":[\"val1\",\"val2\"]}. Multiple fields use AND logic."
                      + " Multiple values within a field use OR logic. Field names are"
                      + " case-insensitive, but values are case-sensitive.",
              required = false)
          String sessionMetadataFilters,
      @ToolParam(description = "Filter to latest session only", required = false)
          Boolean useLatestSession) {

    return executePipeline(
        page,
        pageSize,
        () ->
            SearchAppVulnerabilitiesParams.of(
                appId,
                severities,
                statuses,
                vulnTypes,
                environments,
                lastSeenAfter,
                lastSeenBefore,
                vulnTags,
                sessionMetadataFilters,
                useLatestSession));
  }

  @Override
  protected ExecutionResult<VulnLight> doExecute(
      PaginationParams pagination, SearchAppVulnerabilitiesParams params, List<String> warnings)
      throws Exception {

    var sdk = getContrastSDK();
    var orgId = getOrgId();
    var appId = params.appId();
    var sdkExtension = new SDKExtension(sdk);

    // Handle useLatestSession - fetch agent session ID
    String agentSessionId = null;
    if (Boolean.TRUE.equals(params.getUseLatestSession())) {
      var latestSession = sdkExtension.getLatestSessionMetadata(orgId, appId);
      if (latestSession != null
          && latestSession.getAgentSession() != null
          && latestSession.getAgentSession().getAgentSessionId() != null) {
        agentSessionId = latestSession.getAgentSession().getAgentSessionId();
        log.debug("Using latest session ID: {}", agentSessionId);
      } else {
        warnings.add(
            "No sessions found for this application. Returning all vulnerabilities across all"
                + " sessions for this application.");
        log.warn("No sessions found for application: {}", appId);
      }
    }

    // Handle sessionMetadataFilters - resolve field names to numeric IDs
    List<TraceMetadataFilter> resolvedFilters = null;
    var sessionMetadataFilters = params.getSessionMetadataFilters();
    if (sessionMetadataFilters != null && !sessionMetadataFilters.isEmpty()) {
      resolvedFilters = resolveSessionMetadataFilters(sdk, orgId, appId, sessionMetadataFilters);
      log.debug("Resolved {} session metadata filters", resolvedFilters.size());
    }

    // Build filter body and add session params if present
    var filterBody = params.toTraceFilterBody();
    if (agentSessionId != null) {
      filterBody.setAgentSessionId(agentSessionId);
    }
    if (resolvedFilters != null && !resolvedFilters.isEmpty()) {
      filterBody.setMetadataFilters(resolvedFilters);
    }

    var expand =
        EnumSet.of(
            TraceExpandValue.SESSION_METADATA,
            TraceExpandValue.SERVER_ENVIRONMENTS,
            TraceExpandValue.APPLICATION);

    var traces =
        sdkExtension.getTraces(
            orgId, appId, filterBody, pagination.limit(), pagination.offset(), expand);

    if (traces == null || traces.getTraces() == null) {
      warnings.add("API returned no trace data. Verify permissions and filters.");
      return ExecutionResult.empty();
    }

    var vulnerabilities =
        traces.getTraces().stream().map(vulnerabilityMapper::toVulnLight).toList();

    return ExecutionResult.of(vulnerabilities, traces.getCount());
  }

  /**
   * Resolves session metadata filter names to numeric IDs and builds TraceMetadataFilter list.
   *
   * @param sdk ContrastSDK instance
   * @param orgId Organization ID
   * @param appId Application ID
   * @param filters List of unresolved metadata filters (from parsed JSON)
   * @return List of TraceMetadataFilter with resolved field IDs
   * @throws IllegalArgumentException if any field name is not found
   */
  private List<TraceMetadataFilter> resolveSessionMetadataFilters(
      ContrastSDK sdk, String orgId, String appId, List<UnresolvedMetadataFilter> filters)
      throws Exception {

    var fieldNameToId = buildFieldNameToIdMapping(sdk, orgId, appId);

    var notFoundFields =
        filters.stream()
            .map(UnresolvedMetadataFilter::fieldName)
            .filter(name -> !fieldNameToId.containsKey(name.toLowerCase()))
            .toList();

    if (!notFoundFields.isEmpty()) {
      throw new IllegalArgumentException(
          String.format(
              "Session metadata field(s) not found for application '%s': %s. "
                  + "Use get_session_metadata(appId) to discover available field names.",
              appId, String.join(", ", notFoundFields)));
    }

    return filters.stream()
        .map(
            f -> {
              var fieldId = fieldNameToId.get(f.fieldName().toLowerCase());
              log.debug("Resolved session metadata field '{}' to ID '{}'", f.fieldName(), fieldId);
              return new TraceMetadataFilter(fieldId, f.values());
            })
        .toList();
  }

  /**
   * Builds a case-insensitive mapping from field names to their numeric IDs.
   *
   * @param sdk ContrastSDK instance
   * @param orgId Organization ID
   * @param appId Application ID
   * @return Map of lowercase field names to numeric IDs
   */
  private Map<String, String> buildFieldNameToIdMapping(ContrastSDK sdk, String orgId, String appId)
      throws Exception {

    var metadata = sdk.getSessionMetadataForApplication(orgId, appId, null);
    if (metadata == null || metadata.getFilters() == null) {
      return Map.of();
    }

    var mapping = new HashMap<String, String>();
    for (var filter : metadata.getFilters()) {
      if (filter.getLabel() != null && filter.getId() != null) {
        mapping.put(filter.getLabel().toLowerCase(), filter.getId());
      }
    }
    return mapping;
  }
}
