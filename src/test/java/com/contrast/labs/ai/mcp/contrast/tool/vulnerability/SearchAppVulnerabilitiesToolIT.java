/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.tool.vulnerability;

import static org.assertj.core.api.Assertions.assertThat;

import com.contrast.labs.ai.mcp.contrast.config.IntegrationTestConfig;
import com.contrast.labs.ai.mcp.contrast.tool.application.SearchApplicationsTool;
import com.contrast.labs.ai.mcp.contrast.util.AbstractIntegrationTest;
import java.io.IOException;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;

/**
 * Integration test for SearchAppVulnerabilitiesTool that validates application-scoped vulnerability
 * search against real TeamServer.
 *
 * <p>This test only runs if CONTRAST_HOST_NAME environment variable is set.
 *
 * <p>Required environment variables:
 *
 * <ul>
 *   <li>CONTRAST_HOST_NAME (e.g., app.contrastsecurity.com)
 *   <li>CONTRAST_API_KEY
 *   <li>CONTRAST_SERVICE_KEY
 *   <li>CONTRAST_USERNAME
 *   <li>CONTRAST_ORG_ID
 * </ul>
 *
 * <p>Run locally: source .env.integration-test && mvn verify
 */
@Slf4j
@SpringBootTest
@Import(IntegrationTestConfig.class)
@EnabledIfEnvironmentVariable(named = "CONTRAST_HOST_NAME", matches = ".+")
public class SearchAppVulnerabilitiesToolIT
    extends AbstractIntegrationTest<SearchAppVulnerabilitiesToolIT.TestData> {

  @Autowired private SearchAppVulnerabilitiesTool searchAppVulnerabilitiesTool;
  @Autowired private SearchApplicationsTool searchApplicationsTool;

  /** Container for discovered test data. */
  static class TestData {
    boolean hasApplications;
    String sampleAppId;
    String sampleAppName;

    @Override
    public String toString() {
      return String.format(
          "TestData{hasApplications=%s, sampleAppId='%s', sampleAppName='%s'}",
          hasApplications, sampleAppId, sampleAppName);
    }
  }

  @Override
  protected String testDisplayName() {
    return "SearchAppVulnerabilitiesTool Integration Test";
  }

  @Override
  protected Class<TestData> testDataType() {
    return TestData.class;
  }

  @Override
  protected void logTestDataDetails(TestData data) {
    log.info(
        "Test data: hasApplications={}, sampleAppId={}, sampleAppName={}",
        data.hasApplications,
        data.sampleAppId,
        data.sampleAppName);
  }

  @Override
  protected TestData performDiscovery() throws IOException {
    var response = searchApplicationsTool.searchApplications(1, 5, null, null, null, null);

    var testData = new TestData();
    testData.hasApplications = response.isSuccess() && !response.items().isEmpty();

    if (testData.hasApplications) {
      var firstApp = response.items().get(0);
      testData.sampleAppId = firstApp.appID();
      testData.sampleAppName = firstApp.name();
    }

    log.info(
        "Discovery: found {} applications (hasApps={})",
        response.items().size(),
        testData.hasApplications);

    return testData;
  }

  @Test
  void searchAppVulnerabilities_should_return_validation_error_for_missing_appId() {
    var result =
        searchAppVulnerabilitiesTool.searchAppVulnerabilities(
            null, 1, 10, null, null, null, null, null, null, null, null, null);

    assertThat(result.isSuccess()).isFalse();
    assertThat(result.errors()).anyMatch(e -> e.contains("appId") && e.contains("required"));
  }

  @Test
  void searchAppVulnerabilities_should_return_valid_response() {
    // First get an app ID
    var appsResponse = searchApplicationsTool.searchApplications(1, 1, null, null, null, null);

    if (!appsResponse.isSuccess() || appsResponse.items().isEmpty()) {
      log.warn("No applications found in org - skipping test");
      return;
    }

    var appId = appsResponse.items().get(0).appID();

    var response =
        searchAppVulnerabilitiesTool.searchAppVulnerabilities(
            appId, 1, 10, null, null, null, null, null, null, null, null, null);

    assertThat(response).isNotNull();
    assertThat(response.isSuccess()).isTrue();
    assertThat(response.page()).isEqualTo(1);
    assertThat(response.pageSize()).isEqualTo(10);
    assertThat(response.items()).isNotNull();

    log.info("Found {} vulnerabilities in app {}", response.items().size(), appId);
  }

  @Test
  void searchAppVulnerabilities_should_populate_session_metadata() {
    var appsResponse = searchApplicationsTool.searchApplications(1, 1, null, null, null, null);

    if (!appsResponse.isSuccess() || appsResponse.items().isEmpty()) {
      log.warn("No applications found in org - skipping test");
      return;
    }

    var appId = appsResponse.items().get(0).appID();
    var appName = appsResponse.items().get(0).name();

    log.info("Calling search_app_vulnerabilities() for app: {} (ID: {})", appName, appId);

    var response =
        searchAppVulnerabilitiesTool.searchAppVulnerabilities(
            appId, 1, 50, null, null, null, null, null, null, null, null, null);

    assertThat(response).as("Response should not be null").isNotNull();
    assertThat(response.isSuccess()).isTrue();
    assertThat(response.items()).as("Vulnerabilities list should not be null").isNotNull();

    log.info("Retrieved {} vulnerability(ies)", response.items().size());

    if (response.items().isEmpty()) {
      log.info("No vulnerabilities for this app (this is OK for the test)");
      return;
    }

    // Verify session metadata is populated
    int withSessionMetadata = 0;
    for (var vuln : response.items()) {
      assertThat(vuln.sessionMetadata()).as("Session metadata should never be null").isNotNull();

      if (!vuln.sessionMetadata().isEmpty()) {
        withSessionMetadata++;
        log.info("Vuln {} has {} session(s)", vuln.vulnID(), vuln.sessionMetadata().size());
      }
    }

    log.info(
        "Vulnerabilities with session metadata: {}/{}",
        withSessionMetadata,
        response.items().size());
    log.info("search_app_vulnerabilities() returns vulnerabilities with session metadata");
  }

  @Test
  void searchAppVulnerabilities_should_support_useLatestSession() {
    var appsResponse = searchApplicationsTool.searchApplications(1, 1, null, null, null, null);

    if (!appsResponse.isSuccess() || appsResponse.items().isEmpty()) {
      log.warn("No applications found in org - skipping test");
      return;
    }

    var appId = appsResponse.items().get(0).appID();
    var appName = appsResponse.items().get(0).name();

    log.info(
        "Calling search_app_vulnerabilities(useLatestSession=true) for app: {} (ID: {})",
        appName,
        appId);

    var response =
        searchAppVulnerabilitiesTool.searchAppVulnerabilities(
            appId, 1, 50, null, null, null, null, null, null, null, null, true);

    assertThat(response).as("Response should not be null").isNotNull();
    assertThat(response.isSuccess()).isTrue();
    assertThat(response.items()).as("Vulnerabilities list should not be null").isNotNull();

    log.info("Retrieved {} vulnerability(ies) for latest session", response.items().size());

    if (response.items().isEmpty()) {
      // Check if warning about no sessions
      if (response.warnings().stream().anyMatch(w -> w.contains("No sessions found"))) {
        log.info("No sessions found for this app - returning all vulns (this is OK)");
      } else {
        log.info("No vulnerabilities in latest session (this is valid)");
      }
      return;
    }

    // Verify session metadata is populated in results
    int withSessionMetadata = 0;
    for (var vuln : response.items()) {
      assertThat(vuln.sessionMetadata()).as("Session metadata should never be null").isNotNull();

      if (!vuln.sessionMetadata().isEmpty()) {
        withSessionMetadata++;
        var sessionId = vuln.sessionMetadata().get(0).getSessionId();
        log.info("Vuln {} has session ID: {}", vuln.vulnID(), sessionId);
      }
    }

    log.info("Vulnerabilities returned: {}", response.items().size());
    log.info(
        "Vulnerabilities with session metadata: {}/{}",
        withSessionMetadata,
        response.items().size());
    log.info("search_app_vulnerabilities(useLatestSession=true) works correctly");
  }

  @Test
  void searchAppVulnerabilities_should_filter_by_severity() {
    var appsResponse = searchApplicationsTool.searchApplications(1, 1, null, null, null, null);

    if (!appsResponse.isSuccess() || appsResponse.items().isEmpty()) {
      log.warn("No applications found in org - skipping test");
      return;
    }

    var appId = appsResponse.items().get(0).appID();

    var response =
        searchAppVulnerabilitiesTool.searchAppVulnerabilities(
            appId, 1, 10, "CRITICAL,HIGH", null, null, null, null, null, null, null, null);

    assertThat(response.isSuccess()).isTrue();

    // If we have results, verify they match filter
    if (!response.items().isEmpty()) {
      assertThat(response.items())
          .allMatch(
              v ->
                  "Critical".equalsIgnoreCase(v.severity())
                      || "High".equalsIgnoreCase(v.severity()));
      log.info("All {} results match severity filter CRITICAL,HIGH", response.items().size());
    }
  }

  @Test
  void searchAppVulnerabilities_should_handle_pagination() {
    var appsResponse = searchApplicationsTool.searchApplications(1, 1, null, null, null, null);

    if (!appsResponse.isSuccess() || appsResponse.items().isEmpty()) {
      log.warn("No applications found in org - skipping test");
      return;
    }

    var appId = appsResponse.items().get(0).appID();

    // First page
    var page1 =
        searchAppVulnerabilitiesTool.searchAppVulnerabilities(
            appId, 1, 5, null, null, null, null, null, null, null, null, null);

    assertThat(page1.isSuccess()).isTrue();

    // If there are more pages, fetch page 2
    if (page1.hasMorePages()) {
      var page2 =
          searchAppVulnerabilitiesTool.searchAppVulnerabilities(
              appId, 2, 5, null, null, null, null, null, null, null, null, null);

      assertThat(page2.isSuccess()).isTrue();
      assertThat(page2.page()).isEqualTo(2);
      log.info(
          "Pagination works: page 1 has {}, page 2 has {} items",
          page1.items().size(),
          page2.items().size());
    }
  }

  @Test
  void searchAppVulnerabilities_should_reject_invalid_sessionMetadataFilters_json() {
    var appsResponse = searchApplicationsTool.searchApplications(1, 1, null, null, null, null);

    if (!appsResponse.isSuccess() || appsResponse.items().isEmpty()) {
      log.warn("No applications found in org - skipping test");
      return;
    }

    var appId = appsResponse.items().get(0).appID();

    var response =
        searchAppVulnerabilitiesTool.searchAppVulnerabilities(
            appId,
            1,
            10,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            "not valid json", // invalid JSON
            null);

    assertThat(response.isSuccess()).isFalse();
    assertThat(response.errors()).anyMatch(e -> e.contains("Invalid JSON"));
    log.info("Validation correctly rejects invalid JSON for sessionMetadataFilters");
  }

  @Test
  void searchAppVulnerabilities_should_return_error_for_invalid_sessionMetadataFilters_field() {
    var appsResponse = searchApplicationsTool.searchApplications(1, 1, null, null, null, null);

    if (!appsResponse.isSuccess() || appsResponse.items().isEmpty()) {
      log.warn("No applications found in org - skipping test");
      return;
    }

    var appId = appsResponse.items().get(0).appID();

    // Use a field name that definitely doesn't exist
    var response =
        searchAppVulnerabilitiesTool.searchAppVulnerabilities(
            appId,
            1,
            10,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            "{\"nonexistent_field_xyz_12345\":\"value\"}", // field name that doesn't exist
            null);

    // Should return an error, not a 400 Bad Request
    assertThat(response.isSuccess()).isFalse();
    assertThat(response.errors()).anyMatch(e -> e.contains("not found") || e.contains("Invalid"));

    log.info(
        "Correctly returns error for invalid sessionMetadataFilters field: {}", response.errors());
  }
}
