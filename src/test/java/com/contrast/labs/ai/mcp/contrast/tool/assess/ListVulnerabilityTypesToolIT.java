/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.tool.assess;

import static org.assertj.core.api.Assertions.assertThat;

import com.contrast.labs.ai.mcp.contrast.config.IntegrationTestConfig;
import com.contrast.labs.ai.mcp.contrast.util.AbstractIntegrationTest;
import java.io.IOException;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;

/**
 * Integration test for ListVulnerabilityTypesTool that validates vulnerability type listing against
 * real TeamServer.
 *
 * <p>This test only runs if CONTRAST_HOST_NAME environment variable is set.
 *
 * <p>Required environment variables:
 *
 * <ul>
 *   <li>CONTRAST_HOST_NAME (e.g., app.contrastsecurity.com)
 *   <li>CONTRAST_API_KEY
 *   <li>CONTRAST_SERVICE_KEY
 *   <li>CONTRAST_USERNAME
 *   <li>CONTRAST_ORG_ID
 * </ul>
 *
 * <p>Run locally: source .env.integration-test && mvn verify
 */
@Slf4j
@SpringBootTest
@Import(IntegrationTestConfig.class)
@EnabledIfEnvironmentVariable(named = "CONTRAST_HOST_NAME", matches = ".+")
public class ListVulnerabilityTypesToolIT
    extends AbstractIntegrationTest<ListVulnerabilityTypesToolIT.TestData> {

  @Autowired private ListVulnerabilityTypesTool listVulnerabilityTypesTool;

  /** Container for discovered test data - minimal for this tool. */
  static class TestData {
    boolean apiAccessible;

    @Override
    public String toString() {
      return String.format("TestData{apiAccessible=%s}", apiAccessible);
    }
  }

  @Override
  protected String testDisplayName() {
    return "ListVulnerabilityTypesTool Integration Test";
  }

  @Override
  protected Class<TestData> testDataType() {
    return TestData.class;
  }

  @Override
  protected void logTestDataDetails(TestData data) {
    log.info("Test data: apiAccessible={}", data.apiAccessible);
  }

  @Override
  protected TestData performDiscovery() throws IOException {
    // Just verify we can access the API
    var response = listVulnerabilityTypesTool.listVulnerabilityTypes();

    var testData = new TestData();
    testData.apiAccessible = response.isSuccess();

    log.info("Discovery: API accessible={}", testData.apiAccessible);

    return testData;
  }

  @Test
  void listVulnerabilityTypes_should_return_valid_response() {
    var response = listVulnerabilityTypesTool.listVulnerabilityTypes();

    assertThat(response).isNotNull();
    assertThat(response.isSuccess()).isTrue();
    assertThat(response.found()).isTrue();
    assertThat(response.data()).isNotNull();

    log.info("Retrieved {} vulnerability types", response.data().size());
  }

  @Test
  void listVulnerabilityTypes_should_return_non_empty_list() {
    var response = listVulnerabilityTypesTool.listVulnerabilityTypes();

    assertThat(response.isSuccess()).isTrue();
    assertThat(response.data()).isNotEmpty();

    // Should have common vulnerability types
    log.info("First 10 vulnerability types: {}", response.data().stream().limit(10).toList());
  }

  @Test
  void listVulnerabilityTypes_should_return_sorted_list() {
    var response = listVulnerabilityTypesTool.listVulnerabilityTypes();

    assertThat(response.isSuccess()).isTrue();
    assertThat(response.data()).isNotEmpty();

    // Verify sorted alphabetically
    var types = response.data();
    for (int i = 1; i < types.size(); i++) {
      assertThat(types.get(i).compareTo(types.get(i - 1)))
          .as("List should be sorted alphabetically at index %d", i)
          .isGreaterThanOrEqualTo(0);
    }

    log.info("All {} vulnerability types are sorted alphabetically", types.size());
  }

  @Test
  void listVulnerabilityTypes_should_contain_common_vulnerability_types() {
    var response = listVulnerabilityTypesTool.listVulnerabilityTypes();

    assertThat(response.isSuccess()).isTrue();

    // Should contain some well-known vulnerability types (case-insensitive check)
    var typesLower = response.data().stream().map(String::toLowerCase).toList();

    // Check for at least some common types (may not have all depending on org config)
    boolean hasInjection =
        typesLower.stream()
            .anyMatch(t -> t.contains("injection") || t.contains("sql") || t.contains("xss"));

    if (hasInjection) {
      log.info("Found common injection-related vulnerability types");
    } else {
      log.info(
          "Note: No common injection types found (may be org-specific). Types: {}",
          response.data().stream().limit(20).toList());
    }

    // The main assertion is that we got valid data back
    assertThat(response.data()).allMatch(type -> type != null && !type.trim().isEmpty());
    log.info("All vulnerability types are non-null and non-empty");
  }

  @Test
  void listVulnerabilityTypes_should_have_no_errors() {
    var response = listVulnerabilityTypesTool.listVulnerabilityTypes();

    assertThat(response.isSuccess()).isTrue();
    assertThat(response.errors()).isEmpty();

    log.info("No errors returned from list_vulnerability_types");
  }
}
