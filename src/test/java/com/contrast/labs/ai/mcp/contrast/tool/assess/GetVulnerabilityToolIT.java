/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.tool.assess;

import static org.assertj.core.api.Assertions.assertThat;

import com.contrast.labs.ai.mcp.contrast.config.IntegrationTestConfig;
import com.contrast.labs.ai.mcp.contrast.util.AbstractIntegrationTest;
import java.io.IOException;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;

/**
 * Integration test for GetVulnerabilityTool that validates vulnerability retrieval against real
 * TeamServer.
 *
 * <p>This test only runs if CONTRAST_HOST_NAME environment variable is set.
 *
 * <p>Required environment variables:
 *
 * <ul>
 *   <li>CONTRAST_HOST_NAME (e.g., app.contrastsecurity.com)
 *   <li>CONTRAST_API_KEY
 *   <li>CONTRAST_SERVICE_KEY
 *   <li>CONTRAST_USERNAME
 *   <li>CONTRAST_ORG_ID
 * </ul>
 *
 * <p>Run locally: source .env.integration-test && mvn verify
 */
@Slf4j
@SpringBootTest
@Import(IntegrationTestConfig.class)
@EnabledIfEnvironmentVariable(named = "CONTRAST_HOST_NAME", matches = ".+")
public class GetVulnerabilityToolIT
    extends AbstractIntegrationTest<GetVulnerabilityToolIT.TestData> {

  @Autowired private GetVulnerabilityTool getVulnerabilityTool;
  @Autowired private SearchVulnerabilitiesTool searchVulnerabilitiesTool;

  /** Container for discovered test data. */
  static class TestData {
    boolean hasVulnerabilities;
    String sampleVulnId;
    String sampleAppId;

    @Override
    public String toString() {
      return String.format(
          "TestData{hasVulnerabilities=%s, sampleVulnId='%s', sampleAppId='%s'}",
          hasVulnerabilities, sampleVulnId, sampleAppId);
    }
  }

  @Override
  protected String testDisplayName() {
    return "GetVulnerabilityTool Integration Test";
  }

  @Override
  protected Class<TestData> testDataType() {
    return TestData.class;
  }

  @Override
  protected void logTestDataDetails(TestData data) {
    log.info(
        "Test data: hasVulnerabilities={}, sampleVulnId={}, sampleAppId={}",
        data.hasVulnerabilities,
        data.sampleVulnId,
        data.sampleAppId);
  }

  @Override
  protected TestData performDiscovery() throws IOException {
    var response =
        searchVulnerabilitiesTool.searchVulnerabilities(
            1, 5, null, null, null, null, null, null, null);

    var testData = new TestData();
    testData.hasVulnerabilities = response.isSuccess() && !response.items().isEmpty();

    if (testData.hasVulnerabilities) {
      var firstVuln = response.items().get(0);
      testData.sampleVulnId = firstVuln.vulnID();
      testData.sampleAppId = firstVuln.appID();
    }

    log.info(
        "Discovery: found {} vulnerabilities (hasVulns={})",
        response.items().size(),
        testData.hasVulnerabilities);

    return testData;
  }

  @Test
  void getVulnerability_should_return_validation_error_for_missing_vulnId() {
    var result = getVulnerabilityTool.getVulnerability(null, "some-app-id");

    assertThat(result.isSuccess()).isFalse();
    assertThat(result.errors()).anyMatch(e -> e.contains("vulnId") && e.contains("required"));
  }

  @Test
  void getVulnerability_should_return_validation_error_for_missing_appId() {
    var result = getVulnerabilityTool.getVulnerability("some-vuln-id", null);

    assertThat(result.isSuccess()).isFalse();
    assertThat(result.errors()).anyMatch(e -> e.contains("appId") && e.contains("required"));
  }

  @Test
  void getVulnerability_should_retrieve_vulnerability_directly() {
    // First, find a vulnerability to test with
    var searchResponse =
        searchVulnerabilitiesTool.searchVulnerabilities(
            1, 1, null, null, null, null, null, null, null);

    if (!searchResponse.isSuccess() || searchResponse.items().isEmpty()) {
      log.warn("No vulnerabilities found in org - skipping test");
      return;
    }

    var testVuln = searchResponse.items().get(0);
    var vulnId = testVuln.vulnID();
    var appId = testVuln.appID();

    log.info("Testing with vulnerability: {} in app: {}", vulnId, appId);

    // Now test getVulnerability
    var result = getVulnerabilityTool.getVulnerability(vulnId, appId);

    assertThat(result).as("Response should not be null").isNotNull();
    assertThat(result.isSuccess()).as("Should succeed").isTrue();
    assertThat(result.found()).as("Should find the vulnerability").isTrue();

    var vulnerability = result.data();
    assertThat(vulnerability).as("Vulnerability should not be null").isNotNull();

    // Core identification fields
    assertThat(vulnerability.vulnID()).as("VulnID should match").isEqualTo(vulnId);
    assertThat(vulnerability.title()).as("Title should not be null").isNotNull();
    assertThat(vulnerability.type()).as("Type should not be null").isNotNull();
    assertThat(vulnerability.severity()).as("Severity should not be null").isNotNull();
    assertThat(vulnerability.status()).as("Status should not be null").isNotNull();

    // Application correlation fields
    assertThat(vulnerability.appID()).as("AppID should not be null").isNotNull();
    assertThat(vulnerability.appName()).as("AppName should not be null").isNotNull();

    // Timestamp fields (ISO-8601 formatted)
    assertThat(vulnerability.firstSeenAt()).as("FirstSeenAt should not be null").isNotNull();
    assertThat(vulnerability.lastSeenAt()).as("LastSeenAt should not be null").isNotNull();

    // Collection fields
    assertThat(vulnerability.environments()).as("Environments should not be null").isNotNull();
    assertThat(vulnerability.tags()).as("Tags should not be null").isNotNull();
    assertThat(vulnerability.sessionMetadata())
        .as("SessionMetadata should not be null")
        .isNotNull();

    // Detail-specific fields (only in full Vulnerability, not VulnLight)
    assertThat(vulnerability.hint()).as("Hint should not be null").isNotNull();
    assertThat(vulnerability.howToFix()).as("HowToFix should not be null").isNotNull();
    assertThat(vulnerability.stackTrace()).as("StackTrace should not be null").isNotNull();
    assertThat(vulnerability.vulnerableLibraries())
        .as("VulnerableLibraries should not be null")
        .isNotNull();

    log.info(
        "Successfully retrieved vulnerability: {} - {} ({}, {})",
        vulnerability.vulnID(),
        vulnerability.title(),
        vulnerability.severity(),
        vulnerability.type());
    log.info("  App: {} ({})", vulnerability.appName(), vulnerability.appID());
    log.info(
        "  First seen: {}, Last seen: {}", vulnerability.firstSeenAt(), vulnerability.lastSeenAt());
    log.info("  Environments: {}", vulnerability.environments());
    log.info("  Tags: {}", vulnerability.tags());
    log.info("  Stack trace entries: {}", vulnerability.stackTrace().size());
    log.info("  Vulnerable libraries: {}", vulnerability.vulnerableLibraries().size());

    log.info("All Vulnerability fields populated correctly");
  }

  @Test
  void getVulnerability_should_handle_nonexistent_vuln_gracefully() {
    // Use a discovered app ID with a fake vuln ID
    var searchResponse =
        searchVulnerabilitiesTool.searchVulnerabilities(
            1, 1, null, null, null, null, null, null, null);

    if (!searchResponse.isSuccess() || searchResponse.items().isEmpty()) {
      log.warn("No vulnerabilities found in org - skipping test");
      return;
    }

    var appId = searchResponse.items().get(0).appID();

    var result = getVulnerabilityTool.getVulnerability("nonexistent-vuln-id-12345", appId);

    // Should not throw - should return not found or error response
    assertThat(result).isNotNull();
    // Either found=false or isSuccess=false is acceptable
    if (result.isSuccess()) {
      assertThat(result.found()).isFalse();
    }
    log.info("Nonexistent vulnerability handled gracefully");
  }
}
