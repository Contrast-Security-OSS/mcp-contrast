/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.tool.assess;

import static org.assertj.core.api.Assertions.assertThat;

import com.contrast.labs.ai.mcp.contrast.config.IntegrationTestConfig;
import com.contrast.labs.ai.mcp.contrast.util.AbstractIntegrationTest;
import java.io.IOException;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;

/**
 * Integration test for GetVulnerabilityTool that validates single vulnerability retrieval against
 * real TeamServer.
 *
 * <p>This test validates that the refactored tool produces identical results to the original
 * AssessService.getVulnerabilityById() method.
 *
 * <p>This test only runs if CONTRAST_HOST_NAME environment variable is set.
 *
 * <p>Required environment variables:
 *
 * <ul>
 *   <li>CONTRAST_HOST_NAME (e.g., app.contrastsecurity.com)
 *   <li>CONTRAST_API_KEY
 *   <li>CONTRAST_SERVICE_KEY
 *   <li>CONTRAST_USERNAME
 *   <li>CONTRAST_ORG_ID
 * </ul>
 *
 * <p>Run locally: source .env.integration-test && mvn verify
 */
@Slf4j
@SpringBootTest
@Import(IntegrationTestConfig.class)
@EnabledIfEnvironmentVariable(named = "CONTRAST_HOST_NAME", matches = ".+")
public class GetVulnerabilityToolIT
    extends AbstractIntegrationTest<GetVulnerabilityToolIT.TestData> {

  @Autowired private GetVulnerabilityTool getVulnerabilityTool;
  @Autowired private SearchVulnerabilitiesTool searchVulnerabilitiesTool;

  /** Container for discovered test data - stores a vulnerability to retrieve. */
  static class TestData {
    String vulnId;
    String appId;
    String vulnTitle;

    @Override
    public String toString() {
      return String.format(
          "TestData{vulnId='%s', appId='%s', title='%s'}", vulnId, appId, vulnTitle);
    }
  }

  @Override
  protected String testDisplayName() {
    return "GetVulnerabilityTool Integration Test";
  }

  @Override
  protected Class<TestData> testDataType() {
    return TestData.class;
  }

  @Override
  protected void logTestDataDetails(TestData data) {
    log.info("Test data: vulnId={}, appId={}, title={}", data.vulnId, data.appId, data.vulnTitle);
  }

  @Override
  protected TestData performDiscovery() throws IOException {
    // Find a vulnerability to use for testing
    var response =
        searchVulnerabilitiesTool.searchVulnerabilities(
            1, 1, null, null, null, null, null, null, null);

    if (!response.isSuccess() || response.items().isEmpty()) {
      throw new NoTestDataException(
          "No vulnerabilities found in organization. "
              + "GetVulnerabilityTool integration tests require at least one vulnerability.");
    }

    var vuln = response.items().get(0);
    var testData = new TestData();
    testData.vulnId = vuln.vulnID();
    testData.appId = vuln.appID();
    testData.vulnTitle = vuln.title();

    log.info("Discovery: found vulnerability {} in app {}", testData.vulnId, testData.appId);

    return testData;
  }

  @Test
  void getVulnerability_should_return_validation_error_for_missing_vulnId() {
    var result = getVulnerabilityTool.getVulnerability(null, "some-app-id");

    assertThat(result.isSuccess()).isFalse();
    assertThat(result.errors()).anyMatch(e -> e.contains("vulnId") && e.contains("required"));
  }

  @Test
  void getVulnerability_should_return_validation_error_for_missing_appId() {
    var result = getVulnerabilityTool.getVulnerability("some-vuln-id", null);

    assertThat(result.isSuccess()).isFalse();
    assertThat(result.errors()).anyMatch(e -> e.contains("appId") && e.contains("required"));
  }

  /**
   * Validates that getVulnerability retrieves a vulnerability directly by ID. This is the primary
   * test that proves the refactored tool works identically to the original
   * AssessService.getVulnerabilityById() method.
   *
   * <p>Original test:
   * AssessServiceIntegrationTest.testGetVulnerabilityById_RetrievesVulnerabilityDirectly()
   */
  @Test
  void getVulnerability_should_retrieve_vulnerability_directly_by_id() {
    var response = getVulnerabilityTool.getVulnerability(testData.vulnId, testData.appId);

    assertThat(response).as("Response should not be null").isNotNull();
    assertThat(response.isSuccess()).as("Request should succeed").isTrue();
    assertThat(response.found()).as("Vulnerability should be found").isTrue();

    var vulnerability = response.data();
    assertThat(vulnerability).as("Vulnerability data should not be null").isNotNull();

    // Core identification fields
    assertThat(vulnerability.vulnID())
        .as("VulnID should match requested")
        .isEqualTo(testData.vulnId);
    assertThat(vulnerability.title()).as("Title should not be null").isNotNull();
    assertThat(vulnerability.type()).as("Type should not be null").isNotNull();
    assertThat(vulnerability.severity()).as("Severity should not be null").isNotNull();
    assertThat(vulnerability.status()).as("Status should not be null").isNotNull();

    // Application correlation fields
    assertThat(vulnerability.appID()).as("AppID should not be null").isNotNull();
    assertThat(vulnerability.appName()).as("AppName should not be null").isNotNull();

    // Timestamp fields (ISO-8601 formatted)
    assertThat(vulnerability.firstSeenAt()).as("FirstSeenAt should not be null").isNotNull();
    assertThat(vulnerability.lastSeenAt()).as("LastSeenAt should not be null").isNotNull();

    // Collection fields (should never be null, may be empty)
    assertThat(vulnerability.environments()).as("Environments should not be null").isNotNull();
    assertThat(vulnerability.tags()).as("Tags should not be null").isNotNull();
    assertThat(vulnerability.sessionMetadata())
        .as("SessionMetadata should not be null")
        .isNotNull();

    // Detail-specific fields (should never be null, may be empty)
    assertThat(vulnerability.hint()).as("Hint should not be null").isNotNull();
    assertThat(vulnerability.howToFix()).as("HowToFix should not be null").isNotNull();
    assertThat(vulnerability.stackTrace()).as("StackTrace should not be null").isNotNull();
    assertThat(vulnerability.vulnerableLibraries())
        .as("VulnerableLibraries should not be null")
        .isNotNull();

    log.info(
        "✓ Successfully retrieved vulnerability: {} - {} ({}, {})",
        vulnerability.vulnID(),
        vulnerability.title(),
        vulnerability.severity(),
        vulnerability.type());
    log.info("  App: {} ({})", vulnerability.appName(), vulnerability.appID());
    log.info(
        "  First seen: {}, Last seen: {}", vulnerability.firstSeenAt(), vulnerability.lastSeenAt());
    log.info("  Environments: {}", vulnerability.environments());
    log.info("  Tags: {}", vulnerability.tags());
    log.info("  Stack trace entries: {}", vulnerability.stackTrace().size());
    log.info("  Vulnerable libraries: {}", vulnerability.vulnerableLibraries().size());
  }

  @Test
  void getVulnerability_should_return_not_found_for_invalid_id() {
    var response = getVulnerabilityTool.getVulnerability("INVALID-VULN-ID-12345", testData.appId);

    assertThat(response).as("Response should not be null").isNotNull();
    // The response may be an error or not-found depending on how the API responds
    // Either way, we should not get a successful data response
    if (response.isSuccess()) {
      assertThat(response.found()).as("Should not find invalid vulnerability").isFalse();
    }

    log.info("✓ Invalid vulnerability ID handled correctly");
  }

  @Test
  void getVulnerability_should_populate_remediation_guidance() {
    var response = getVulnerabilityTool.getVulnerability(testData.vulnId, testData.appId);

    assertThat(response.isSuccess()).isTrue();
    var vulnerability = response.data();

    // Hint is AI-generated based on vulnerability type - should always be present
    assertThat(vulnerability.hint())
        .as("Hint should provide remediation guidance")
        .isNotNull()
        .isNotEmpty();

    // HowToFix comes from Contrast's recommendation API - may vary by vuln type
    assertThat(vulnerability.howToFix()).as("HowToFix field should exist").isNotNull();

    log.info("✓ Remediation guidance populated");
    log.info(
        "  Hint: {}",
        vulnerability.hint().substring(0, Math.min(100, vulnerability.hint().length())) + "...");
    if (!vulnerability.howToFix().isEmpty()) {
      log.info(
          "  HowToFix: {}",
          vulnerability.howToFix().substring(0, Math.min(100, vulnerability.howToFix().length()))
              + "...");
    }
  }

  @Test
  void getVulnerability_should_include_warnings_for_unavailable_data() {
    var response = getVulnerabilityTool.getVulnerability(testData.vulnId, testData.appId);

    assertThat(response.isSuccess()).isTrue();
    assertThat(response.warnings()).as("Warnings list should exist").isNotNull();

    // Warnings indicate graceful degradation when optional data isn't available
    // This is expected behavior, not an error
    if (!response.warnings().isEmpty()) {
      log.info("✓ Warnings present for unavailable optional data:");
      response.warnings().forEach(w -> log.info("  - {}", w));
    } else {
      log.info("✓ All optional data was available (no warnings)");
    }
  }
}
