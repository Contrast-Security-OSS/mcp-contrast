/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.tool.vulnerability;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;
import static org.mockito.Mockito.when;

import com.contrast.labs.ai.mcp.contrast.config.ContrastSDKFactory;
import com.contrast.labs.ai.mcp.contrast.result.Vulnerability;
import com.contrastsecurity.models.Trace;
import com.contrastsecurity.sdk.ContrastSDK;
import java.util.EnumSet;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.test.util.ReflectionTestUtils;

class GetVulnerabilityToolTest {

  private static final String VALID_VULN_ID = "vuln-123";
  private static final String VALID_APP_ID = "app-123";
  private static final String ORG_ID = "test-org-id";

  private GetVulnerabilityTool tool;
  private VulnerabilityMapper mapper;
  private ContrastSDKFactory sdkFactory;
  private ContrastSDK sdk;

  @BeforeEach
  void setUp() {
    mapper = mock();
    sdk = mock();
    sdkFactory = mock();

    when(sdkFactory.getSDK()).thenReturn(sdk);
    when(sdkFactory.getOrgId()).thenReturn(ORG_ID);

    tool = new GetVulnerabilityTool(mapper);
    ReflectionTestUtils.setField(tool, "sdkFactory", sdkFactory);
  }

  @Test
  void getVulnerability_should_return_validation_error_when_vulnId_missing() {
    var result = tool.getVulnerability(null, VALID_APP_ID);

    assertThat(result.isSuccess()).isFalse();
    assertThat(result.errors()).anyMatch(e -> e.contains("vulnId is required"));

    verifyNoInteractions(sdk);
    verifyNoInteractions(mapper);
  }

  @Test
  void getVulnerability_should_return_validation_error_when_appId_missing() {
    var result = tool.getVulnerability(VALID_VULN_ID, null);

    assertThat(result.isSuccess()).isFalse();
    assertThat(result.errors()).anyMatch(e -> e.contains("appId is required"));

    verifyNoInteractions(sdk);
    verifyNoInteractions(mapper);
  }

  @Test
  void getVulnerability_should_return_notFound_when_trace_null() throws Exception {
    when(sdk.getTrace(eq(ORG_ID), eq(VALID_APP_ID), eq(VALID_VULN_ID), any(EnumSet.class)))
        .thenReturn(null);

    var result = tool.getVulnerability(VALID_VULN_ID, VALID_APP_ID);

    assertThat(result.isSuccess()).isTrue(); // Not found is not an error
    assertThat(result.found()).isFalse();
    assertThat(result.data()).isNull();
    assertThat(result.warnings()).anyMatch(w -> w.contains("not found"));
  }

  @Test
  void getVulnerability_should_return_data_when_valid() throws Exception {
    var trace = mock(Trace.class);
    var vulnerability = mock(Vulnerability.class);

    when(sdk.getTrace(eq(ORG_ID), eq(VALID_APP_ID), eq(VALID_VULN_ID), any(EnumSet.class)))
        .thenReturn(trace);
    when(mapper.toFullVulnerability(eq(trace), any(VulnerabilityContext.class)))
        .thenReturn(vulnerability);

    var result = tool.getVulnerability(VALID_VULN_ID, VALID_APP_ID);

    assertThat(result.isSuccess()).isTrue();
    assertThat(result.found()).isTrue();
    assertThat(result.data()).isEqualTo(vulnerability);

    verify(sdk).getTrace(eq(ORG_ID), eq(VALID_APP_ID), eq(VALID_VULN_ID), any(EnumSet.class));
    verify(mapper).toFullVulnerability(eq(trace), any(VulnerabilityContext.class));
  }

  @Test
  void getVulnerability_should_add_warnings_for_partial_data() throws Exception {
    var trace = mock(Trace.class);
    var vulnerability = mock(Vulnerability.class);

    when(sdk.getTrace(eq(ORG_ID), eq(VALID_APP_ID), eq(VALID_VULN_ID), any(EnumSet.class)))
        .thenReturn(trace);
    // Simulate recommendation fetch failure
    when(sdk.getRecommendation(eq(ORG_ID), eq(VALID_VULN_ID)))
        .thenThrow(new RuntimeException("API error"));
    when(mapper.toFullVulnerability(eq(trace), any(VulnerabilityContext.class)))
        .thenReturn(vulnerability);

    var result = tool.getVulnerability(VALID_VULN_ID, VALID_APP_ID);

    assertThat(result.isSuccess()).isTrue();
    assertThat(result.found()).isTrue();
    assertThat(result.warnings()).anyMatch(w -> w.contains("Recommendation data not available"));
  }

  @Test
  void getVulnerability_should_collect_multiple_validation_errors() {
    var result = tool.getVulnerability(null, null);

    assertThat(result.isSuccess()).isFalse();
    assertThat(result.errors()).hasSize(2);
    assertThat(result.errors())
        .anyMatch(e -> e.contains("vulnId is required"))
        .anyMatch(e -> e.contains("appId is required"));
  }
}
