/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast;

import com.contrastsecurity.http.RuleSeverity;
import com.contrastsecurity.http.ServerEnvironment;
import com.contrastsecurity.http.TraceFilterForm;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class VulnerabilityFilterParamsTest {

    @Test
    void testValidFiltersAllProvided() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            "CRITICAL,HIGH",
            "Reported,Confirmed",
            "app123",
            "sql-injection,xss-reflected",
            "PRODUCTION,QA",
            "2025-01-01",
            "2025-12-31",
            "reviewed"
        );

        assertTrue(params.isValid());
        assertTrue(params.errors().isEmpty());
        assertEquals("app123", params.appId());

        TraceFilterForm form = params.toTraceFilterForm();
        assertNotNull(form.getSeverities());
        assertEquals(2, form.getSeverities().size());
        assertTrue(form.getSeverities().contains(RuleSeverity.CRITICAL));
        assertTrue(form.getSeverities().contains(RuleSeverity.HIGH));
    }

    @Test
    void testNoFiltersProvided() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null, null, null, null
        );

        assertTrue(params.isValid());
        assertFalse(params.warnings().isEmpty()); // Should have smart defaults warning
        assertTrue(params.errors().isEmpty());

        // Smart defaults should be applied to status
        TraceFilterForm form = params.toTraceFilterForm();
        assertNotNull(form.getStatus());
        assertEquals(3, form.getStatus().size());
    }

    @Test
    void testInvalidSeverityHardFailure() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            "CRITICAL,SUPER_HIGH",
            null, null, null, null, null, null, null
        );

        assertFalse(params.isValid());
        assertEquals(1, params.errors().size());
        assertTrue(params.errors().get(0).contains("Invalid severity 'SUPER_HIGH'"));
        assertTrue(params.errors().get(0).contains("Valid: CRITICAL, HIGH, MEDIUM, LOW, NOTE"));
    }

    @Test
    void testAllInvalidSeveritiesHardFailure() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            "SUPER_HIGH,ULTRA_CRITICAL",
            null, null, null, null, null, null, null
        );

        assertFalse(params.isValid());
        assertEquals(2, params.errors().size());
    }

    @Test
    void testInvalidStatusHardFailure() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null,
            "Reported,Invalid",
            null, null, null, null, null, null
        );

        assertFalse(params.isValid());
        assertEquals(1, params.errors().size());
        assertTrue(params.errors().get(0).contains("Invalid status 'Invalid'"));
        assertTrue(params.errors().get(0).contains("Valid: Reported, Suspicious, Confirmed, Remediated, Fixed"));
    }

    @Test
    void testMultipleInvalidStatusesHardFailure() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null,
            "Reported,BadStatus,AnotherBad",
            null, null, null, null, null, null
        );

        assertFalse(params.isValid());
        assertEquals(2, params.errors().size());
    }

    @Test
    void testInvalidEnvironmentHardFailure() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null,
            "PRODUCTION,STAGING",
            null, null, null
        );

        assertFalse(params.isValid());
        assertEquals(1, params.errors().size());
        assertTrue(params.errors().get(0).contains("Invalid environment 'STAGING'"));
        assertTrue(params.errors().get(0).contains("Valid: DEVELOPMENT, QA, PRODUCTION"));
    }

    @Test
    void testUnparseableDateHardFailure() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null,
            "not-a-date",
            null, null
        );

        assertFalse(params.isValid());
        assertEquals(1, params.errors().size());
        assertTrue(params.errors().get(0).contains("Invalid lastSeenAfter date 'not-a-date'"));
        assertTrue(params.errors().get(0).contains("Expected ISO format"));
    }

    @Test
    void testDateRangeContradictionHardFailure() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null,
            "2025-12-31",
            "2025-01-01",
            null
        );

        assertFalse(params.isValid());
        assertEquals(1, params.errors().size());
        assertTrue(params.errors().get(0).contains("Invalid date range"));
        assertTrue(params.errors().get(0).contains("lastSeenAfter must be before lastSeenBefore"));
    }

    @Test
    void testValidDateRange() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null,
            "2025-01-01",
            "2025-12-31",
            null
        );

        assertTrue(params.isValid());
        assertTrue(params.errors().isEmpty());
        assertFalse(params.warnings().isEmpty()); // Should have time filter warning and smart defaults warning

        TraceFilterForm form = params.toTraceFilterForm();
        assertNotNull(form.getStartDate());
        assertNotNull(form.getEndDate());
    }

    @Test
    void testEpochTimestampDates() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null,
            "1704067200000",  // 2024-01-01 in epoch
            "1735689600000",  // 2025-01-01 in epoch
            null
        );

        assertTrue(params.isValid());
        assertTrue(params.errors().isEmpty());

        TraceFilterForm form = params.toTraceFilterForm();
        assertNotNull(form.getStartDate());
        assertNotNull(form.getEndDate());
    }

    @Test
    void testSmartDefaultsWarning() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null, null, null, null
        );

        assertTrue(params.isValid());
        assertTrue(params.errors().isEmpty());
        assertEquals(1, params.warnings().size());
        assertTrue(params.warnings().get(0).contains("Showing actionable vulnerabilities only"));
        assertTrue(params.warnings().get(0).contains("excluding Fixed and Remediated"));
    }

    @Test
    void testExplicitStatusesNoSmartDefaultsWarning() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null,
            "Reported,Confirmed",
            null, null, null, null, null, null
        );

        assertTrue(params.isValid());
        assertTrue(params.errors().isEmpty());
        assertTrue(params.warnings().isEmpty()); // No smart defaults warning
    }

    @Test
    void testTimeFilterWarningAdded() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null,
            "2025-01-01",
            null, null
        );

        assertTrue(params.isValid());
        assertTrue(params.errors().isEmpty());
        // Should have both smart defaults warning and time filter warning
        assertEquals(2, params.warnings().size());
        assertTrue(params.warnings().stream().anyMatch(w -> w.contains("Time filters apply to LAST ACTIVITY DATE")));
    }

    @Test
    void testNoTimeFilterWarningWhenDateInvalid() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null,
            "invalid-date",
            null, null
        );

        assertFalse(params.isValid());
        assertFalse(params.errors().isEmpty());
        // Should NOT have time filter warning since date parsing failed
        assertFalse(params.warnings().stream().anyMatch(w -> w.contains("Time filters apply")));
    }

    @Test
    void testVulnTypesPassThrough() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null,
            "sql-injection,xss-reflected,made-up-type",
            null, null, null, null
        );

        assertTrue(params.isValid());
        assertTrue(params.errors().isEmpty());

        TraceFilterForm form = params.toTraceFilterForm();
        assertNotNull(form.getVulnTypes());
        assertEquals(3, form.getVulnTypes().size());
        assertTrue(form.getVulnTypes().contains("sql-injection"));
        assertTrue(form.getVulnTypes().contains("made-up-type")); // Not validated
    }

    @Test
    void testVulnTagsCaseSensitive() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null, null, null,
            "SmartFix Remediated,Reviewed,reviewed"
        );

        assertTrue(params.isValid());

        TraceFilterForm form = params.toTraceFilterForm();
        assertNotNull(form.getFilterTags());
        assertEquals(3, form.getFilterTags().size());
        // SDK now handles URL encoding (AIML-193 complete) - tags passed through as-is
        assertTrue(form.getFilterTags().contains("SmartFix Remediated"));
        assertTrue(form.getFilterTags().contains("Reviewed"));
        assertTrue(form.getFilterTags().contains("reviewed")); // Case preserved
    }

    @Test
    void testVulnTagsWithSpacesAndSpecialChars() {
        // SDK now handles URL encoding (AIML-193 complete) - tags passed through as-is
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null, null, null,
            "Tag With Spaces,tag-hyphen,tag&special"
        );

        assertTrue(params.isValid());
        TraceFilterForm form = params.toTraceFilterForm();
        assertNotNull(form.getFilterTags());
        assertEquals(3, form.getFilterTags().size());
        assertEquals("Tag With Spaces", form.getFilterTags().get(0));
        assertEquals("tag-hyphen", form.getFilterTags().get(1));
        assertEquals("tag&special", form.getFilterTags().get(2));
    }

    @Test
    void testMultipleErrorsAccumulate() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            "SUPER_HIGH",
            "BadStatus",
            null, null,
            "STAGING",
            "bad-date",
            null, null
        );

        assertFalse(params.isValid());
        assertEquals(4, params.errors().size()); // 4 different validation errors
    }

    @Test
    void testAppIdPassedThrough() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, "my-app-123", null, null, null, null, null
        );

        assertTrue(params.isValid());
        assertEquals("my-app-123", params.appId());
    }

    @Test
    void testWarningsAreImmutable() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            null, null, null, null, null, null, null, null
        );

        assertThrows(UnsupportedOperationException.class, () -> {
            params.warnings().add("Should fail");
        });
    }

    @Test
    void testErrorsAreImmutable() {
        VulnerabilityFilterParams params = VulnerabilityFilterParams.of(
            "INVALID",
            null, null, null, null, null, null, null
        );

        assertThrows(UnsupportedOperationException.class, () -> {
            params.errors().add("Should fail");
        });
    }
}
