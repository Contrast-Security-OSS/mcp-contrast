/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import com.contrastsecurity.http.RuleSeverity;
import com.contrastsecurity.http.TraceFilterForm;
import org.junit.jupiter.api.Test;

class VulnerabilityFilterParamsTest {

  @Test
  void testValidFiltersAllProvided() {
    var params =
        VulnerabilityFilterParams.of(
            "CRITICAL,HIGH",
            "Reported,Confirmed",
            "sql-injection,xss-reflected",
            "PRODUCTION,QA",
            "2025-01-01",
            "2025-12-31",
            "reviewed");

    assertThat(params.isValid()).isTrue();
    assertThat(params.errors()).isEmpty();

    var form = params.toTraceFilterForm();
    assertThat(form.getSeverities()).isNotNull();
    assertThat(form.getSeverities()).hasSize(2);
    assertThat(form.getSeverities()).contains(RuleSeverity.CRITICAL);
    assertThat(form.getSeverities()).contains(RuleSeverity.HIGH);
  }

  @Test
  void testNoFiltersProvided() {
    var params = VulnerabilityFilterParams.of(null, null, null, null, null, null, null);

    assertThat(params.isValid()).isTrue();
    assertThat(params.warnings()).isNotEmpty(); // Should have smart defaults warning
    assertThat(params.errors()).isEmpty();

    // Smart defaults should be applied to status
    var form = params.toTraceFilterForm();
    assertThat(form.getStatus()).isNotNull();
    assertThat(form.getStatus()).hasSize(3);
  }

  @Test
  void testInvalidSeverityHardFailure() {
    var params =
        VulnerabilityFilterParams.of("CRITICAL,SUPER_HIGH", null, null, null, null, null, null);

    assertThat(params.isValid()).isFalse();
    assertThat(params.errors()).hasSize(1);
    assertThat(params.errors().get(0)).contains("Invalid severity 'SUPER_HIGH'");
    assertThat(params.errors().get(0)).contains("Valid: CRITICAL, HIGH, MEDIUM, LOW, NOTE");
  }

  @Test
  void testAllInvalidSeveritiesHardFailure() {
    var params =
        VulnerabilityFilterParams.of(
            "SUPER_HIGH,ULTRA_CRITICAL", null, null, null, null, null, null);

    assertThat(params.isValid()).isFalse();
    assertThat(params.errors()).hasSize(2);
  }

  @Test
  void testInvalidStatusHardFailure() {
    var params =
        VulnerabilityFilterParams.of(null, "Reported,Invalid", null, null, null, null, null);

    assertThat(params.isValid()).isFalse();
    assertThat(params.errors()).hasSize(1);
    assertThat(params.errors().get(0)).contains("Invalid status 'Invalid'");
    assertThat(params.errors().get(0))
        .contains("Valid: Reported, Suspicious, Confirmed, Remediated, Fixed");
  }

  @Test
  void testMultipleInvalidStatusesHardFailure() {
    var params =
        VulnerabilityFilterParams.of(
            null, "Reported,BadStatus,AnotherBad", null, null, null, null, null);

    assertThat(params.isValid()).isFalse();
    assertThat(params.errors()).hasSize(2);
  }

  @Test
  void testInvalidEnvironmentHardFailure() {
    var params =
        VulnerabilityFilterParams.of(null, null, null, "PRODUCTION,STAGING", null, null, null);

    assertThat(params.isValid()).isFalse();
    assertThat(params.errors()).hasSize(1);
    assertThat(params.errors().get(0)).contains("Invalid environment 'STAGING'");
    assertThat(params.errors().get(0)).contains("Valid: DEVELOPMENT, QA, PRODUCTION");
  }

  @Test
  void testUnparseableDateHardFailure() {
    var params = VulnerabilityFilterParams.of(null, null, null, null, "not-a-date", null, null);

    assertThat(params.isValid()).isFalse();
    assertThat(params.errors()).hasSize(1);
    assertThat(params.errors().get(0)).contains("Invalid lastSeenAfter date 'not-a-date'");
    assertThat(params.errors().get(0)).contains("Expected ISO format");
  }

  @Test
  void testDateRangeContradictionHardFailure() {
    var params =
        VulnerabilityFilterParams.of(null, null, null, null, "2025-12-31", "2025-01-01", null);

    assertThat(params.isValid()).isFalse();
    assertThat(params.errors()).hasSize(1);
    assertThat(params.errors().get(0)).contains("Invalid date range");
    assertThat(params.errors().get(0)).contains("lastSeenAfter must be before lastSeenBefore");
  }

  @Test
  void testValidDateRange() {
    var params =
        VulnerabilityFilterParams.of(null, null, null, null, "2025-01-01", "2025-12-31", null);

    assertThat(params.isValid()).isTrue();
    assertThat(params.errors()).isEmpty();
    assertThat(params.warnings())
        .isNotEmpty(); // Should have time filter warning and smart defaults warning

    var form = params.toTraceFilterForm();
    assertThat(form.getStartDate()).isNotNull();
    assertThat(form.getEndDate()).isNotNull();
  }

  @Test
  void testEpochTimestampDates() {
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of(
            null,
            null,
            null,
            null,
            "1704067200000", // 2024-01-01 in epoch
            "1735689600000", // 2025-01-01 in epoch
            null);

    assertThat(params.isValid()).isTrue();
    assertThat(params.errors()).isEmpty();

    TraceFilterForm form = params.toTraceFilterForm();
    assertThat(form.getStartDate()).isNotNull();
    assertThat(form.getEndDate()).isNotNull();
  }

  @Test
  void testSmartDefaultsWarning() {
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of(null, null, null, null, null, null, null);

    assertThat(params.isValid()).isTrue();
    assertThat(params.errors()).isEmpty();
    assertThat(params.warnings()).hasSize(1);
    assertThat(params.warnings().get(0)).contains("Showing actionable vulnerabilities only");
    assertThat(params.warnings().get(0)).contains("excluding Fixed and Remediated");
  }

  @Test
  void testExplicitStatusesNoSmartDefaultsWarning() {
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of(null, "Reported,Confirmed", null, null, null, null, null);

    assertThat(params.isValid()).isTrue();
    assertThat(params.errors()).isEmpty();
    assertThat(params.warnings()).isEmpty(); // No smart defaults warning
  }

  @Test
  void testTimeFilterWarningAdded() {
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of(null, null, null, null, "2025-01-01", null, null);

    assertThat(params.isValid()).isTrue();
    assertThat(params.errors()).isEmpty();
    // Should have both smart defaults warning and time filter warning
    assertThat(params.warnings()).hasSize(2);
    assertThat(
            params.warnings().stream()
                .anyMatch(w -> w.contains("Time filters apply to LAST ACTIVITY DATE")))
        .isTrue();
  }

  @Test
  void testNoTimeFilterWarningWhenDateInvalid() {
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of(null, null, null, null, "invalid-date", null, null);

    assertThat(params.isValid()).isFalse();
    assertThat(params.errors()).isNotEmpty();
    // Should NOT have time filter warning since date parsing failed
    assertThat(params.warnings()).noneMatch(w -> w.contains("Time filters apply"));
  }

  @Test
  void testVulnTypesPassThrough() {
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of(
            null, null, "sql-injection,xss-reflected,made-up-type", null, null, null, null);

    assertThat(params.isValid()).isTrue();
    assertThat(params.errors()).isEmpty();

    TraceFilterForm form = params.toTraceFilterForm();
    assertThat(form.getVulnTypes()).isNotNull();
    assertThat(form.getVulnTypes()).hasSize(3);
    assertThat(form.getVulnTypes()).contains("sql-injection");
    assertThat(form.getVulnTypes()).contains("made-up-type"); // Not validated
  }

  @Test
  void testVulnTagsCaseSensitive() {
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of(
            null, null, null, null, null, null, "SmartFix Remediated,Reviewed,reviewed");

    assertThat(params.isValid()).isTrue();

    TraceFilterForm form = params.toTraceFilterForm();
    assertThat(form.getFilterTags()).isNotNull();
    assertThat(form.getFilterTags()).hasSize(3);
    // SDK now handles URL encoding (AIML-193 complete) - tags passed through as-is
    assertThat(form.getFilterTags()).contains("SmartFix Remediated");
    assertThat(form.getFilterTags()).contains("Reviewed");
    assertThat(form.getFilterTags()).contains("reviewed"); // Case preserved
  }

  @Test
  void testVulnTagsWithSpacesAndSpecialChars() {
    // SDK now handles URL encoding (AIML-193 complete) - tags passed through as-is
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of(
            null, null, null, null, null, null, "Tag With Spaces,tag-hyphen,tag&special");

    assertThat(params.isValid()).isTrue();
    TraceFilterForm form = params.toTraceFilterForm();
    assertThat(form.getFilterTags()).isNotNull();
    assertThat(form.getFilterTags()).hasSize(3);
    assertThat(form.getFilterTags().get(0)).isEqualTo("Tag With Spaces");
    assertThat(form.getFilterTags().get(1)).isEqualTo("tag-hyphen");
    assertThat(form.getFilterTags().get(2)).isEqualTo("tag&special");
  }

  @Test
  void testMultipleErrorsAccumulate() {
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of(
            "SUPER_HIGH", "BadStatus", null, "STAGING", "bad-date", null, null);

    assertThat(params.isValid()).isFalse();
    assertThat(params.errors()).hasSize(4); // 4 different validation errors
  }

  @Test
  void testWarningsAreImmutable() {
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of(null, null, null, null, null, null, null);

    assertThatThrownBy(() -> params.warnings().add("Should fail"))
        .isInstanceOf(UnsupportedOperationException.class);
  }

  @Test
  void testErrorsAreImmutable() {
    VulnerabilityFilterParams params =
        VulnerabilityFilterParams.of("INVALID", null, null, null, null, null, null);

    assertThatThrownBy(() -> params.errors().add("Should fail"))
        .isInstanceOf(UnsupportedOperationException.class);
  }
}
