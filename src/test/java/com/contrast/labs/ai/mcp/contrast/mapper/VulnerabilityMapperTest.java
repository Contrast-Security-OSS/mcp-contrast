/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.mapper;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import com.contrast.labs.ai.mcp.contrast.data.StackLib;
import com.contrast.labs.ai.mcp.contrast.sdkextension.data.LibraryExtended;
import com.contrastsecurity.models.Application;
import com.contrastsecurity.models.SessionMetadata;
import com.contrastsecurity.models.Trace;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.Arrays;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

/** Test suite for VulnerabilityMapper to ensure proper transformation logic. */
class VulnerabilityMapperTest {

  private VulnerabilityMapper mapper;

  // Named constants for test timestamps
  private static final long JAN_15_2025_10_30_UTC =
      LocalDateTime.of(2025, 1, 15, 10, 30)
          .toInstant(ZoneOffset.UTC)
          .toEpochMilli(); // 1736938200000L
  private static final long JAN_14_2025_09_30_UTC =
      LocalDateTime.of(2025, 1, 14, 9, 30)
          .toInstant(ZoneOffset.UTC)
          .toEpochMilli(); // 1736848200000L
  private static final long JAN_14_2025_10_30_UTC =
      LocalDateTime.of(2025, 1, 14, 10, 30)
          .toInstant(ZoneOffset.UTC)
          .toEpochMilli(); // 1705242000000L
  private static final long JAN_16_2025_10_30_UTC =
      LocalDateTime.of(2025, 1, 16, 10, 30)
          .toInstant(ZoneOffset.UTC)
          .toEpochMilli(); // 1705414800000L

  @BeforeEach
  void setUp() {
    mapper = new VulnerabilityMapper();
  }

  @Test
  void toVulnLight_BasicTrace_TransformsCorrectly() {
    // Arrange
    Trace trace = mock();
    Application app = mock();
    when(app.getId()).thenReturn("app-123");
    when(app.getName()).thenReturn("Test Application");

    when(trace.getApplication()).thenReturn(app);
    when(trace.getTitle()).thenReturn("SQL Injection");
    when(trace.getRule()).thenReturn("sql-injection");
    when(trace.getUuid()).thenReturn("vuln-123");
    when(trace.getSeverity()).thenReturn("CRITICAL");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());
    when(trace.getSessionMetadata()).thenReturn(null); // No session metadata expanded

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.title()).isEqualTo("SQL Injection");
    assertThat(result.type()).isEqualTo("sql-injection");
    assertThat(result.vulnID()).isEqualTo("vuln-123");
    assertThat(result.severity()).isEqualTo("CRITICAL");
    assertThat(result.appID()).isEqualTo("app-123");
    assertThat(result.appName()).isEqualTo("Test Application");
    assertThat(result.status()).isEqualTo("Reported");
    assertThat(result.lastSeenAt()).isNotNull();
    assertThat(result.firstSeenAt()).isNotNull();
    assertThat(result.closedAt()).isNull();
    assertThat(result.sessionMetadata()).isEmpty();
    assertThat(result.environments()).isEmpty();
  }

  @Test
  void toVulnLight_TraceWithEnvironments_ExtractsEnvironments() {
    // Arrange
    Trace trace = mock();

    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-789");
    when(trace.getSeverity()).thenReturn("MEDIUM");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments())
        .thenReturn(Arrays.asList("PRODUCTION", "QA", "PRODUCTION")); // With duplicate
    when(trace.getTags()).thenReturn(new ArrayList<>());

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.environments()).hasSize(2);
    assertThat(result.environments()).contains("PRODUCTION");
    assertThat(result.environments()).contains("QA");
    // Verify they're sorted
    assertThat(result.environments().get(0)).isEqualTo("PRODUCTION");
    assertThat(result.environments().get(1)).isEqualTo("QA");
  }

  @Test
  void toVulnLight_NullTimestamps_HandledGracefully() {
    // Arrange
    Trace trace = mock();
    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-null");
    when(trace.getSeverity()).thenReturn("LOW");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(null);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.lastSeenAt()).isNotNull();
    assertThat(result.firstSeenAt()).isNull();
    assertThat(result.closedAt()).isNull();
  }

  @Test
  void toFullVulnerability_WithContext_TransformsCorrectly() {
    // Arrange
    Trace trace = mock();
    when(trace.getUuid()).thenReturn("vuln-full");
    when(trace.getTitle()).thenReturn("Command Injection");
    when(trace.getRule()).thenReturn("cmd-injection");
    when(trace.getSeverity()).thenReturn("High");
    when(trace.getStatus()).thenReturn("Confirmed");
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);

    // Mock application
    var app = mock(com.contrastsecurity.models.Application.class);
    when(app.getId()).thenReturn("app-123");
    when(app.getName()).thenReturn("Test Application");
    when(trace.getApplication()).thenReturn(app);

    // Mock environments, tags, session metadata
    when(trace.getServerEnvironments()).thenReturn(Arrays.asList("PRODUCTION", "QA"));
    when(trace.getTags()).thenReturn(Arrays.asList("reviewed", "critical"));
    when(trace.getSessionMetadata()).thenReturn(new ArrayList<>());

    var stackLib = new StackLib("at com.example.Test.method()", "lib-hash-123");
    LibraryExtended library = mock();

    var context =
        VulnerabilityContext.builder()
            .recommendation("Sanitize user input")
            .stackLibs(Arrays.asList(stackLib))
            .libraries(Arrays.asList(library))
            .httpRequest("GET /api/test")
            .build();

    // Act
    var result = mapper.toFullVulnerability(trace, context);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.vulnID()).isEqualTo("vuln-full");
    assertThat(result.title()).isEqualTo("Command Injection");
    assertThat(result.type()).isEqualTo("cmd-injection");
    assertThat(result.severity()).isEqualTo("High");
    assertThat(result.appID()).isEqualTo("app-123");
    assertThat(result.appName()).isEqualTo("Test Application");
    assertThat(result.status()).isEqualTo("Confirmed");
    assertThat(result.howToFix()).isEqualTo("Sanitize user input");
    assertThat(result.stackTrace()).hasSize(1);
    assertThat(result.stackTrace().get(0)).isEqualTo(stackLib);
    assertThat(result.vulnerableLibraries()).hasSize(1);
    assertThat(result.vulnerableLibraries().get(0)).isEqualTo(library);
    assertThat(result.httpRequest()).isEqualTo("GET /api/test");
    assertThat(result.hint()).isNotNull();
    assertThat(result.hint()).isNotEmpty(); // HintGenerator provides guidance
    assertThat(result.environments()).containsExactly("PRODUCTION", "QA");
    assertThat(result.tags()).containsExactly("reviewed", "critical");
    assertThat(result.sessionMetadata()).isEmpty();
    assertThat(result.firstSeenAt()).isNotNull();
    assertThat(result.lastSeenAt()).isNotNull();
  }

  @Test
  void toVulnLight_EnvironmentsWithNullAndEmpty_FiltersCorrectly() {
    // Arrange
    Trace trace = mock();

    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-env-filter");
    when(trace.getSeverity()).thenReturn("HIGH");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments())
        .thenReturn(Arrays.asList("PRODUCTION", null, "", "DEVELOPMENT"));
    when(trace.getTags()).thenReturn(new ArrayList<>());

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.environments()).hasSize(2);
    assertThat(result.environments()).contains("PRODUCTION");
    assertThat(result.environments()).contains("DEVELOPMENT");
    assertThat(result.environments()).doesNotContain((String) null);
    assertThat(result.environments()).doesNotContain("");
  }

  @Test
  void toVulnLight_ISO8601TimestampFormat_Validated() {
    // Arrange
    Trace trace = mock();
    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-timestamp");
    when(trace.getSeverity()).thenReturn("CRITICAL");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_10_30_UTC);
    when(trace.getClosedTime()).thenReturn(JAN_16_2025_10_30_UTC);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    // Verify ISO 8601 format with timezone offset
    assertThat(result.lastSeenAt())
        .matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}");
    assertThat(result.firstSeenAt())
        .matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}");
    assertThat(result.closedAt())
        .matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}");
    assertThat(result.lastSeenAt()).contains("T"); // Has time separator
    assertThat(result.lastSeenAt()).contains(":"); // Has time colons
    assertThat(result.lastSeenAt()).matches(".*[+-]\\d{2}:\\d{2}$"); // Has timezone offset
  }

  @Test
  void toVulnLight_TraceWithTags_ExtractsTags() {
    // Arrange
    Trace trace = mock();
    var tags = Arrays.asList("SmartFix Remediated", "reviewed", "high-priority");

    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-with-tags");
    when(trace.getSeverity()).thenReturn("CRITICAL");
    when(trace.getStatus()).thenReturn("Remediated");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(tags);

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.tags()).isNotNull();
    assertThat(result.tags()).hasSize(3);
    assertThat(result.tags()).contains("SmartFix Remediated");
    assertThat(result.tags()).contains("reviewed");
    assertThat(result.tags()).contains("high-priority");
  }

  @Test
  void toVulnLight_TraceWithNullTags_ReturnsEmptyList() {
    // Arrange
    Trace trace = mock();

    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-null-tags");
    when(trace.getSeverity()).thenReturn("MEDIUM");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(null);

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.tags()).isNotNull();
    assertThat(result.tags()).isEmpty();
  }

  @Test
  void toVulnLight_TraceWithEmptyTags_ReturnsEmptyList() {
    // Arrange
    Trace trace = mock();

    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-empty-tags");
    when(trace.getSeverity()).thenReturn("LOW");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.tags()).isNotNull();
    assertThat(result.tags()).isEmpty();
  }

  @Test
  void toVulnLight_TraceWithSessionMetadata_ExtractsSessionMetadata() {
    // Arrange - Test that SDK Trace now includes session metadata when expanded
    Trace trace = mock();
    SessionMetadata sessionMeta = mock();
    var sessionMetadataList = Arrays.asList(sessionMeta);

    when(trace.getTitle()).thenReturn("SQL Injection");
    when(trace.getRule()).thenReturn("sql-injection");
    when(trace.getUuid()).thenReturn("vuln-with-session");
    when(trace.getSeverity()).thenReturn("CRITICAL");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());
    when(trace.getSessionMetadata()).thenReturn(sessionMetadataList);

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.type()).isEqualTo("sql-injection");
    assertThat(result.sessionMetadata()).hasSize(1);
    assertThat(result.sessionMetadata().get(0)).isEqualTo(sessionMeta);
  }

  @Test
  void toVulnLight_TraceWithNullSessionMetadata_ReturnsEmptyList() {
    // Arrange - Test that SDK Trace handles null session metadata gracefully
    Trace trace = mock();

    when(trace.getTitle()).thenReturn("XSS");
    when(trace.getRule()).thenReturn("xss-reflected");
    when(trace.getUuid()).thenReturn("vuln-no-session-sdk");
    when(trace.getSeverity()).thenReturn("HIGH");
    when(trace.getStatus()).thenReturn("Confirmed");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());
    when(trace.getSessionMetadata()).thenReturn(null);

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.sessionMetadata()).isNotNull();
    assertThat(result.sessionMetadata()).isEmpty();
  }

  @Test
  void toVulnLight_TraceWithEmptySessionMetadata_ReturnsEmptyList() {
    // Arrange - Test that SDK Trace handles empty session metadata list
    Trace trace = mock();

    when(trace.getTitle()).thenReturn("Path Traversal");
    when(trace.getRule()).thenReturn("path-traversal");
    when(trace.getUuid()).thenReturn("vuln-empty-session");
    when(trace.getSeverity()).thenReturn("MEDIUM");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());
    when(trace.getSessionMetadata()).thenReturn(new ArrayList<>());

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.sessionMetadata()).isNotNull();
    assertThat(result.sessionMetadata()).isEmpty();
  }

  @Test
  void toVulnLight_TraceWithNullApplication_HandlesGracefully() {
    // Arrange - Test that mapper handles null application without crashing
    Trace trace = mock();

    when(trace.getApplication()).thenReturn(null); // No application expanded
    when(trace.getTitle()).thenReturn("Test Vuln");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-no-app");
    when(trace.getSeverity()).thenReturn("HIGH");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());
    when(trace.getSessionMetadata()).thenReturn(null);

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.appID()).as("appID should be null when application is not expanded").isNull();
    assertThat(result.appName())
        .as("appName should be null when application is not expanded")
        .isNull();
    assertThat(result.vulnID()).isEqualTo("vuln-no-app");
    assertThat(result.severity()).isEqualTo("HIGH");
  }

  @Test
  void toVulnLight_TraceWithApplication_ExtractsAppData() {
    // Arrange - Test that application data is correctly extracted when expanded
    Trace trace = mock();
    Application app = mock();
    when(app.getId()).thenReturn("app-abc-123");
    when(app.getName()).thenReturn("My Production App");

    when(trace.getApplication()).thenReturn(app);
    when(trace.getTitle()).thenReturn("XSS Vulnerability");
    when(trace.getRule()).thenReturn("xss-reflected");
    when(trace.getUuid()).thenReturn("vuln-with-app");
    when(trace.getSeverity()).thenReturn("CRITICAL");
    when(trace.getStatus()).thenReturn("Confirmed");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(Arrays.asList("PRODUCTION"));
    when(trace.getTags()).thenReturn(Arrays.asList("high-priority"));
    when(trace.getSessionMetadata()).thenReturn(new ArrayList<>());

    // Act
    var result = mapper.toVulnLight(trace);

    // Assert
    assertThat(result).isNotNull();
    assertThat(result.appID()).as("appID should match application ID").isEqualTo("app-abc-123");
    assertThat(result.appName())
        .as("appName should match application name")
        .isEqualTo("My Production App");
    assertThat(result.vulnID()).isEqualTo("vuln-with-app");
    assertThat(result.type()).isEqualTo("xss-reflected");
    assertThat(result.severity()).isEqualTo("CRITICAL");
    assertThat(result.environments()).hasSize(1);
    assertThat(result.environments().get(0)).isEqualTo("PRODUCTION");
    assertThat(result.tags()).hasSize(1);
  }
}
