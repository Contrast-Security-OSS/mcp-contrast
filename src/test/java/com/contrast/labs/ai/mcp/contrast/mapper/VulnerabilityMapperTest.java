/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.mapper;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import com.contrast.labs.ai.mcp.contrast.data.StackLib;
import com.contrast.labs.ai.mcp.contrast.data.VulnLight;
import com.contrast.labs.ai.mcp.contrast.data.Vulnerability;
import com.contrast.labs.ai.mcp.contrast.sdkexstension.data.LibraryExtended;
import com.contrastsecurity.models.Application;
import com.contrastsecurity.models.SessionMetadata;
import com.contrastsecurity.models.Trace;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

/** Test suite for VulnerabilityMapper to ensure proper transformation logic. */
class VulnerabilityMapperTest {

  private VulnerabilityMapper mapper;

  // Named constants for test timestamps
  private static final long JAN_15_2025_10_30_UTC =
      LocalDateTime.of(2025, 1, 15, 10, 30)
          .toInstant(ZoneOffset.UTC)
          .toEpochMilli(); // 1736938200000L
  private static final long JAN_14_2025_09_30_UTC =
      LocalDateTime.of(2025, 1, 14, 9, 30)
          .toInstant(ZoneOffset.UTC)
          .toEpochMilli(); // 1736848200000L
  private static final long JAN_14_2025_10_30_UTC =
      LocalDateTime.of(2025, 1, 14, 10, 30)
          .toInstant(ZoneOffset.UTC)
          .toEpochMilli(); // 1705242000000L
  private static final long JAN_16_2025_10_30_UTC =
      LocalDateTime.of(2025, 1, 16, 10, 30)
          .toInstant(ZoneOffset.UTC)
          .toEpochMilli(); // 1705414800000L

  @BeforeEach
  void setUp() {
    mapper = new VulnerabilityMapper();
  }

  @Test
  void toVulnLight_BasicTrace_TransformsCorrectly() {
    // Arrange
    Trace trace = mock(Trace.class);
    Application app = mock(Application.class);
    when(app.getId()).thenReturn("app-123");
    when(app.getName()).thenReturn("Test Application");

    when(trace.getApplication()).thenReturn(app);
    when(trace.getTitle()).thenReturn("SQL Injection");
    when(trace.getRule()).thenReturn("sql-injection");
    when(trace.getUuid()).thenReturn("vuln-123");
    when(trace.getSeverity()).thenReturn("CRITICAL");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());
    when(trace.getSessionMetadata()).thenReturn(null); // No session metadata expanded

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertEquals("SQL Injection", result.title());
    assertEquals("sql-injection", result.type());
    assertEquals("vuln-123", result.vulnID());
    assertEquals("CRITICAL", result.severity());
    assertEquals("app-123", result.appID());
    assertEquals("Test Application", result.appName());
    assertEquals("Reported", result.status());
    assertNotNull(result.lastSeenAt());
    assertNotNull(result.firstSeenAt());
    assertNull(result.closedAt());
    assertTrue(result.sessionMetadata().isEmpty());
    assertTrue(result.environments().isEmpty());
  }

  @Test
  void toVulnLight_TraceWithEnvironments_ExtractsEnvironments() {
    // Arrange
    Trace trace = mock(Trace.class);

    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-789");
    when(trace.getSeverity()).thenReturn("MEDIUM");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments())
        .thenReturn(Arrays.asList("PRODUCTION", "QA", "PRODUCTION")); // With duplicate
    when(trace.getTags()).thenReturn(new ArrayList<>());

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertEquals(2, result.environments().size());
    assertTrue(result.environments().contains("PRODUCTION"));
    assertTrue(result.environments().contains("QA"));
    // Verify they're sorted
    assertEquals("PRODUCTION", result.environments().get(0));
    assertEquals("QA", result.environments().get(1));
  }

  @Test
  void toVulnLight_NullTimestamps_HandledGracefully() {
    // Arrange
    Trace trace = mock(Trace.class);
    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-null");
    when(trace.getSeverity()).thenReturn("LOW");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(null);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertNotNull(result.lastSeenAt());
    assertNull(result.firstSeenAt());
    assertNull(result.closedAt());
  }

  @Test
  void toFullVulnerability_WithContext_TransformsCorrectly() {
    // Arrange
    Trace trace = mock(Trace.class);
    when(trace.getUuid()).thenReturn("vuln-full");
    when(trace.getTitle()).thenReturn("Command Injection");
    when(trace.getRule()).thenReturn("cmd-injection");
    when(trace.getStatus()).thenReturn("Confirmed");
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);

    StackLib stackLib = new StackLib("at com.example.Test.method()", "lib-hash-123");
    LibraryExtended library = mock(LibraryExtended.class);

    VulnerabilityContext context =
        VulnerabilityContext.builder()
            .recommendation("Sanitize user input")
            .stackLibs(Arrays.asList(stackLib))
            .libraries(Arrays.asList(library))
            .httpRequest("GET /api/test")
            .build();

    // Act
    Vulnerability result = mapper.toFullVulnerability(trace, context);

    // Assert
    assertNotNull(result);
    assertEquals("vuln-full", result.vulnID());
    assertEquals("Command Injection", result.title());
    assertEquals("cmd-injection", result.type());
    assertEquals("Confirmed", result.status());
    assertEquals("Sanitize user input", result.howToFix());
    assertEquals(1, result.stackTrace().size());
    assertEquals(stackLib, result.stackTrace().get(0));
    assertEquals(1, result.vulnerableLibraries().size());
    assertEquals(library, result.vulnerableLibraries().get(0));
    assertEquals("GET /api/test", result.httpRequest());
    assertNotNull(result.hint());
    assertFalse(result.hint().isEmpty()); // HintGenerator provides guidance
  }

  @Test
  void toVulnLight_EnvironmentsWithNullAndEmpty_FiltersCorrectly() {
    // Arrange
    Trace trace = mock(Trace.class);

    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-env-filter");
    when(trace.getSeverity()).thenReturn("HIGH");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments())
        .thenReturn(Arrays.asList("PRODUCTION", null, "", "DEVELOPMENT"));
    when(trace.getTags()).thenReturn(new ArrayList<>());

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertEquals(2, result.environments().size());
    assertTrue(result.environments().contains("PRODUCTION"));
    assertTrue(result.environments().contains("DEVELOPMENT"));
    assertFalse(result.environments().contains(null));
    assertFalse(result.environments().contains(""));
  }

  @Test
  void toVulnLight_ISO8601TimestampFormat_Validated() {
    // Arrange
    Trace trace = mock(Trace.class);
    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-timestamp");
    when(trace.getSeverity()).thenReturn("CRITICAL");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_10_30_UTC);
    when(trace.getClosedTime()).thenReturn(JAN_16_2025_10_30_UTC);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    // Verify ISO 8601 format with timezone offset
    assertTrue(
        result.lastSeenAt().matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}"));
    assertTrue(
        result.firstSeenAt().matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}"));
    assertTrue(
        result.closedAt().matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}"));
    assertTrue(result.lastSeenAt().contains("T")); // Has time separator
    assertTrue(result.lastSeenAt().contains(":")); // Has time colons
    assertTrue(result.lastSeenAt().matches(".*[+-]\\d{2}:\\d{2}$")); // Has timezone offset
  }

  @Test
  void toVulnLight_TraceWithTags_ExtractsTags() {
    // Arrange
    Trace trace = mock(Trace.class);
    List<String> tags = Arrays.asList("SmartFix Remediated", "reviewed", "high-priority");

    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-with-tags");
    when(trace.getSeverity()).thenReturn("CRITICAL");
    when(trace.getStatus()).thenReturn("Remediated");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(tags);

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertNotNull(result.tags());
    assertEquals(3, result.tags().size());
    assertTrue(result.tags().contains("SmartFix Remediated"));
    assertTrue(result.tags().contains("reviewed"));
    assertTrue(result.tags().contains("high-priority"));
  }

  @Test
  void toVulnLight_TraceWithNullTags_ReturnsEmptyList() {
    // Arrange
    Trace trace = mock(Trace.class);

    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-null-tags");
    when(trace.getSeverity()).thenReturn("MEDIUM");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(null);

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertNotNull(result.tags());
    assertTrue(result.tags().isEmpty());
  }

  @Test
  void toVulnLight_TraceWithEmptyTags_ReturnsEmptyList() {
    // Arrange
    Trace trace = mock(Trace.class);

    when(trace.getTitle()).thenReturn("Test");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-empty-tags");
    when(trace.getSeverity()).thenReturn("LOW");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertNotNull(result.tags());
    assertTrue(result.tags().isEmpty());
  }

  @Test
  void toVulnLight_TraceWithSessionMetadata_ExtractsSessionMetadata() {
    // Arrange - Test that SDK Trace now includes session metadata when expanded
    Trace trace = mock(Trace.class);
    SessionMetadata sessionMeta = mock(SessionMetadata.class);
    List<SessionMetadata> sessionMetadataList = Arrays.asList(sessionMeta);

    when(trace.getTitle()).thenReturn("SQL Injection");
    when(trace.getRule()).thenReturn("sql-injection");
    when(trace.getUuid()).thenReturn("vuln-with-session");
    when(trace.getSeverity()).thenReturn("CRITICAL");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());
    when(trace.getSessionMetadata()).thenReturn(sessionMetadataList);

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertEquals("sql-injection", result.type());
    assertEquals(1, result.sessionMetadata().size());
    assertEquals(sessionMeta, result.sessionMetadata().get(0));
  }

  @Test
  void toVulnLight_TraceWithNullSessionMetadata_ReturnsEmptyList() {
    // Arrange - Test that SDK Trace handles null session metadata gracefully
    Trace trace = mock(Trace.class);

    when(trace.getTitle()).thenReturn("XSS");
    when(trace.getRule()).thenReturn("xss-reflected");
    when(trace.getUuid()).thenReturn("vuln-no-session-sdk");
    when(trace.getSeverity()).thenReturn("HIGH");
    when(trace.getStatus()).thenReturn("Confirmed");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());
    when(trace.getSessionMetadata()).thenReturn(null);

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertNotNull(result.sessionMetadata());
    assertTrue(result.sessionMetadata().isEmpty());
  }

  @Test
  void toVulnLight_TraceWithEmptySessionMetadata_ReturnsEmptyList() {
    // Arrange - Test that SDK Trace handles empty session metadata list
    Trace trace = mock(Trace.class);

    when(trace.getTitle()).thenReturn("Path Traversal");
    when(trace.getRule()).thenReturn("path-traversal");
    when(trace.getUuid()).thenReturn("vuln-empty-session");
    when(trace.getSeverity()).thenReturn("MEDIUM");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());
    when(trace.getSessionMetadata()).thenReturn(new ArrayList<>());

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertNotNull(result.sessionMetadata());
    assertTrue(result.sessionMetadata().isEmpty());
  }

  @Test
  void toVulnLight_TraceWithNullApplication_HandlesGracefully() {
    // Arrange - Test that mapper handles null application without crashing
    Trace trace = mock(Trace.class);

    when(trace.getApplication()).thenReturn(null); // No application expanded
    when(trace.getTitle()).thenReturn("Test Vuln");
    when(trace.getRule()).thenReturn("test-rule");
    when(trace.getUuid()).thenReturn("vuln-no-app");
    when(trace.getSeverity()).thenReturn("HIGH");
    when(trace.getStatus()).thenReturn("Reported");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(new ArrayList<>());
    when(trace.getTags()).thenReturn(new ArrayList<>());
    when(trace.getSessionMetadata()).thenReturn(null);

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertNull(result.appID(), "appID should be null when application is not expanded");
    assertNull(result.appName(), "appName should be null when application is not expanded");
    assertEquals("vuln-no-app", result.vulnID());
    assertEquals("HIGH", result.severity());
  }

  @Test
  void toVulnLight_TraceWithApplication_ExtractsAppData() {
    // Arrange - Test that application data is correctly extracted when expanded
    Trace trace = mock(Trace.class);
    Application app = mock(Application.class);
    when(app.getId()).thenReturn("app-abc-123");
    when(app.getName()).thenReturn("My Production App");

    when(trace.getApplication()).thenReturn(app);
    when(trace.getTitle()).thenReturn("XSS Vulnerability");
    when(trace.getRule()).thenReturn("xss-reflected");
    when(trace.getUuid()).thenReturn("vuln-with-app");
    when(trace.getSeverity()).thenReturn("CRITICAL");
    when(trace.getStatus()).thenReturn("Confirmed");
    when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
    when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
    when(trace.getClosedTime()).thenReturn(null);
    when(trace.getServerEnvironments()).thenReturn(Arrays.asList("PRODUCTION"));
    when(trace.getTags()).thenReturn(Arrays.asList("high-priority"));
    when(trace.getSessionMetadata()).thenReturn(new ArrayList<>());

    // Act
    VulnLight result = mapper.toVulnLight(trace);

    // Assert
    assertNotNull(result);
    assertEquals("app-abc-123", result.appID(), "appID should match application ID");
    assertEquals("My Production App", result.appName(), "appName should match application name");
    assertEquals("vuln-with-app", result.vulnID());
    assertEquals("xss-reflected", result.type());
    assertEquals("CRITICAL", result.severity());
    assertEquals(1, result.environments().size());
    assertEquals("PRODUCTION", result.environments().get(0));
    assertEquals(1, result.tags().size());
  }
}
