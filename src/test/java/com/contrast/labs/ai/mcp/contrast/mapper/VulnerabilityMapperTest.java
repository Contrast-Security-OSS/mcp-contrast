/*
 * Copyright 2025 Contrast Security
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.contrast.labs.ai.mcp.contrast.mapper;

import com.contrast.labs.ai.mcp.contrast.data.StackLib;
import com.contrast.labs.ai.mcp.contrast.data.VulnLight;
import com.contrast.labs.ai.mcp.contrast.data.Vulnerability;
import com.contrast.labs.ai.mcp.contrast.sdkexstension.data.LibraryExtended;
import com.contrast.labs.ai.mcp.contrast.sdkexstension.data.traces.SessionMetadata;
import com.contrast.labs.ai.mcp.contrast.sdkexstension.data.traces.TraceExtended;
import com.contrastsecurity.models.Server;
import com.contrastsecurity.models.Trace;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Test suite for VulnerabilityMapper to ensure proper transformation logic.
 */
class VulnerabilityMapperTest {

    private VulnerabilityMapper mapper;

    // Named constants for test timestamps
    private static final long JAN_15_2025_10_30_UTC = LocalDateTime.of(2025, 1, 15, 10, 30)
            .toInstant(ZoneOffset.UTC).toEpochMilli(); // 1736938200000L
    private static final long JAN_14_2025_09_30_UTC = LocalDateTime.of(2025, 1, 14, 9, 30)
            .toInstant(ZoneOffset.UTC).toEpochMilli(); // 1736848200000L
    private static final long JAN_14_2025_10_30_UTC = LocalDateTime.of(2025, 1, 14, 10, 30)
            .toInstant(ZoneOffset.UTC).toEpochMilli(); // 1705242000000L
    private static final long JAN_16_2025_10_30_UTC = LocalDateTime.of(2025, 1, 16, 10, 30)
            .toInstant(ZoneOffset.UTC).toEpochMilli(); // 1705414800000L

    @BeforeEach
    void setUp() {
        mapper = new VulnerabilityMapper();
    }

    @Test
    void toVulnLight_BasicTrace_TransformsCorrectly() {
        // Arrange
        Trace trace = mock(Trace.class);
        when(trace.getTitle()).thenReturn("SQL Injection");
        when(trace.getRule()).thenReturn("sql-injection");
        when(trace.getUuid()).thenReturn("vuln-123");
        when(trace.getSeverity()).thenReturn("CRITICAL");
        when(trace.getStatus()).thenReturn("Reported");
        when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
        when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
        when(trace.getClosedTime()).thenReturn(null);
        when(trace.getServers()).thenReturn(new ArrayList<>());

        // Act
        VulnLight result = mapper.toVulnLight(trace);

        // Assert
        assertNotNull(result);
        assertEquals("SQL Injection", result.title());
        assertEquals("sql-injection", result.type());
        assertEquals("vuln-123", result.vulnID());
        assertEquals("CRITICAL", result.severity());
        assertEquals("Reported", result.status());
        assertNotNull(result.lastSeenAt());
        assertNotNull(result.firstSeenAt());
        assertNull(result.closedAt());
        assertTrue(result.sessionMetadata().isEmpty());
        assertTrue(result.environments().isEmpty());
    }

    @Test
    void toVulnLight_TraceExtended_IncludesSessionMetadata() {
        // Arrange
        TraceExtended trace = mock(TraceExtended.class);
        SessionMetadata sessionMeta = mock(SessionMetadata.class);
        List<SessionMetadata> sessionMetadataList = Arrays.asList(sessionMeta);

        when(trace.getTitle()).thenReturn("XSS");
        when(trace.getRule()).thenReturn("xss-reflected");
        when(trace.getUuid()).thenReturn("vuln-456");
        when(trace.getSeverity()).thenReturn("HIGH");
        when(trace.getStatus()).thenReturn("Confirmed");
        when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
        when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
        when(trace.getClosedTime()).thenReturn(null);
        when(trace.getServers()).thenReturn(new ArrayList<>());
        when(trace.getSessionMetadata()).thenReturn(sessionMetadataList);

        // Act
        VulnLight result = mapper.toVulnLight(trace);

        // Assert
        assertNotNull(result);
        assertEquals("xss-reflected", result.type());
        assertEquals(1, result.sessionMetadata().size());
        assertEquals(sessionMeta, result.sessionMetadata().get(0));
    }

    @Test
    void toVulnLight_TraceWithEnvironments_ExtractsEnvironments() {
        // Arrange
        Trace trace = mock(Trace.class);
        Server server1 = mock(Server.class);
        Server server2 = mock(Server.class);
        Server server3 = mock(Server.class);

        when(server1.getEnvironment()).thenReturn("PRODUCTION");
        when(server2.getEnvironment()).thenReturn("QA");
        when(server3.getEnvironment()).thenReturn("PRODUCTION"); // Duplicate

        when(trace.getTitle()).thenReturn("Test");
        when(trace.getRule()).thenReturn("test-rule");
        when(trace.getUuid()).thenReturn("vuln-789");
        when(trace.getSeverity()).thenReturn("MEDIUM");
        when(trace.getStatus()).thenReturn("Reported");
        when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
        when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
        when(trace.getClosedTime()).thenReturn(null);
        when(trace.getServers()).thenReturn(Arrays.asList(server1, server2, server3));

        // Act
        VulnLight result = mapper.toVulnLight(trace);

        // Assert
        assertNotNull(result);
        assertEquals(2, result.environments().size());
        assertTrue(result.environments().contains("PRODUCTION"));
        assertTrue(result.environments().contains("QA"));
        // Verify they're sorted
        assertEquals("PRODUCTION", result.environments().get(0));
        assertEquals("QA", result.environments().get(1));
    }

    @Test
    void toVulnLight_NullTimestamps_HandledGracefully() {
        // Arrange
        Trace trace = mock(Trace.class);
        when(trace.getTitle()).thenReturn("Test");
        when(trace.getRule()).thenReturn("test-rule");
        when(trace.getUuid()).thenReturn("vuln-null");
        when(trace.getSeverity()).thenReturn("LOW");
        when(trace.getStatus()).thenReturn("Reported");
        when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
        when(trace.getFirstTimeSeen()).thenReturn(null);
        when(trace.getClosedTime()).thenReturn(null);
        when(trace.getServers()).thenReturn(new ArrayList<>());

        // Act
        VulnLight result = mapper.toVulnLight(trace);

        // Assert
        assertNotNull(result);
        assertNotNull(result.lastSeenAt());
        assertNull(result.firstSeenAt());
        assertNull(result.closedAt());
    }

    @Test
    void toFullVulnerability_WithContext_TransformsCorrectly() {
        // Arrange
        Trace trace = mock(Trace.class);
        when(trace.getUuid()).thenReturn("vuln-full");
        when(trace.getTitle()).thenReturn("Command Injection");
        when(trace.getRule()).thenReturn("cmd-injection");
        when(trace.getStatus()).thenReturn("Confirmed");
        when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
        when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
        when(trace.getClosedTime()).thenReturn(null);

        StackLib stackLib = new StackLib("at com.example.Test.method()", "lib-hash-123");
        LibraryExtended library = mock(LibraryExtended.class);

        VulnerabilityContext context = VulnerabilityContext.builder()
            .recommendation("Sanitize user input")
            .stackLibs(Arrays.asList(stackLib))
            .libraries(Arrays.asList(library))
            .httpRequest("GET /api/test")
            .build();

        // Act
        Vulnerability result = mapper.toFullVulnerability(trace, context);

        // Assert
        assertNotNull(result);
        assertEquals("vuln-full", result.vulnID());
        assertEquals("Command Injection", result.title());
        assertEquals("cmd-injection", result.type());
        assertEquals("Confirmed", result.status());
        assertEquals("Sanitize user input", result.howToFix());
        assertEquals(1, result.stackTrace().size());
        assertEquals(stackLib, result.stackTrace().get(0));
        assertEquals(1, result.vulnerableLibraries().size());
        assertEquals(library, result.vulnerableLibraries().get(0));
        assertEquals("GET /api/test", result.httpRequest());
        assertNotNull(result.hint());
        assertFalse(result.hint().isEmpty()); // HintGenerator provides guidance
    }

    @Test
    void toVulnLight_TraceExtendedWithNullSessionMetadata_ReturnsEmptyList() {
        // Arrange
        TraceExtended trace = mock(TraceExtended.class);
        when(trace.getTitle()).thenReturn("Test");
        when(trace.getRule()).thenReturn("test-rule");
        when(trace.getUuid()).thenReturn("vuln-no-session");
        when(trace.getSeverity()).thenReturn("MEDIUM");
        when(trace.getStatus()).thenReturn("Reported");
        when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
        when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
        when(trace.getClosedTime()).thenReturn(null);
        when(trace.getServers()).thenReturn(new ArrayList<>());
        when(trace.getSessionMetadata()).thenReturn(null);

        // Act
        VulnLight result = mapper.toVulnLight(trace);

        // Assert
        assertNotNull(result);
        assertNotNull(result.sessionMetadata());
        assertTrue(result.sessionMetadata().isEmpty());
    }

    @Test
    void toVulnLight_EnvironmentsWithNullAndEmpty_FiltersCorrectly() {
        // Arrange
        Trace trace = mock(Trace.class);
        Server server1 = mock(Server.class);
        Server server2 = mock(Server.class);
        Server server3 = mock(Server.class);
        Server server4 = mock(Server.class);

        when(server1.getEnvironment()).thenReturn("PRODUCTION");
        when(server2.getEnvironment()).thenReturn(null);
        when(server3.getEnvironment()).thenReturn("");
        when(server4.getEnvironment()).thenReturn("DEVELOPMENT");

        when(trace.getTitle()).thenReturn("Test");
        when(trace.getRule()).thenReturn("test-rule");
        when(trace.getUuid()).thenReturn("vuln-env-filter");
        when(trace.getSeverity()).thenReturn("HIGH");
        when(trace.getStatus()).thenReturn("Reported");
        when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
        when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_09_30_UTC);
        when(trace.getClosedTime()).thenReturn(null);
        when(trace.getServers()).thenReturn(Arrays.asList(server1, server2, server3, server4));

        // Act
        VulnLight result = mapper.toVulnLight(trace);

        // Assert
        assertNotNull(result);
        assertEquals(2, result.environments().size());
        assertTrue(result.environments().contains("PRODUCTION"));
        assertTrue(result.environments().contains("DEVELOPMENT"));
        assertFalse(result.environments().contains(null));
        assertFalse(result.environments().contains(""));
    }

    @Test
    void toVulnLight_ISO8601TimestampFormat_Validated() {
        // Arrange
        Trace trace = mock(Trace.class);
        when(trace.getTitle()).thenReturn("Test");
        when(trace.getRule()).thenReturn("test-rule");
        when(trace.getUuid()).thenReturn("vuln-timestamp");
        when(trace.getSeverity()).thenReturn("CRITICAL");
        when(trace.getStatus()).thenReturn("Reported");
        when(trace.getLastTimeSeen()).thenReturn(JAN_15_2025_10_30_UTC);
        when(trace.getFirstTimeSeen()).thenReturn(JAN_14_2025_10_30_UTC);
        when(trace.getClosedTime()).thenReturn(JAN_16_2025_10_30_UTC);
        when(trace.getServers()).thenReturn(new ArrayList<>());

        // Act
        VulnLight result = mapper.toVulnLight(trace);

        // Assert
        assertNotNull(result);
        // Verify ISO 8601 format with timezone offset
        assertTrue(result.lastSeenAt().matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}"));
        assertTrue(result.firstSeenAt().matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}"));
        assertTrue(result.closedAt().matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}"));
        assertTrue(result.lastSeenAt().contains("T")); // Has time separator
        assertTrue(result.lastSeenAt().contains(":")); // Has time colons
        assertTrue(result.lastSeenAt().matches(".*[+-]\\d{2}:\\d{2}$")); // Has timezone offset
    }
}
