# Test Plan: get_vulnerability Tool

> **NOTE (AIML-189)**: As of the consolidation in AIML-189, the duplicate `get_vulnerability` (app_name variant) tool has been removed. The remaining tool has been renamed from `get_vulnerability_by_id` to `get_vulnerability` and now exclusively uses application ID as input. Users should call `list_applications_with_name` first to get the application ID from a name.

## Overview
This test plan provides comprehensive testing coverage for the `get_vulnerability` MCP tool (formerly `get_vulnerability_by_id`) in AssessService.java. This tool retrieves detailed vulnerability information including stacktraces, recommendations, HTTP request data, and associated library CVE data.

## Tool Signature
- **Tool Name**: `get_vulnerability_by_id`
- **Parameters**:
  - `vulnID` (String): The unique identifier for the vulnerability
  - `appID` (String): The application identifier containing the vulnerability
- **Returns**: Vulnerability object with detailed information

## Expected Output Structure
The tool returns a `Vulnerability` object containing:
- `hint` - Contextual security guidance
- `vulnID` - Vulnerability identifier
- `title` - Vulnerability title
- `type` - Vulnerability type/category
- `howToFix` - Remediation recommendation text
- `stackTrace` - List of StackLib objects (stacktrace line + library hash mapping)
- `vulnerableLibraries` - List of LibraryExtended objects with CVE data
- `httpRequest` - HTTP request text that triggered the vulnerability
- `status` - Current vulnerability status
- `firstTimeSeen` - Timestamp of first detection
- `lastTimeSeen` - Timestamp of last detection
- `closedTime` - Timestamp when closed (if applicable)

---

## Test Suite

### Category 1: Basic Functionality

#### Test 1.1: Retrieve Valid Vulnerability with Complete Data
**Objective**: Verify the tool can successfully retrieve a vulnerability with all data populated

**Prerequisites**:
- Assume a vulnerability exists in the Contrast system with a known vulnID and appID
- The vulnerability should have stacktraces, recommendations, HTTP request data, and be in an open/reported status

**Test Steps**:
1. Query the Contrast installation to find a vulnerability with complete data (use `list_all_vulnerabilities` tool to find candidates)
2. Note the vulnID and appID for a vulnerability that appears to have rich data
3. Call `get_vulnerability_by_id` with the identified vulnID and appID
4. Verify the response is returned successfully without errors

**Expected Results**:
- Tool returns a Vulnerability object
- No exceptions or error messages
- Response time is reasonable (< 10 seconds)

**Validation Criteria**:
- `vulnID` matches the requested ID
- `title` is a non-empty string
- `type` contains a valid vulnerability type
- `status` is present and valid
- Timestamps (firstTimeSeen, lastTimeSeen) are valid epoch times

---

#### Test 1.2: Retrieve Multiple Different Vulnerabilities
**Objective**: Verify the tool works consistently across different vulnerability types

**Prerequisites**:
- Assume at least 3 different vulnerabilities exist in different applications

**Test Steps**:
1. Use `list_all_vulnerabilities` to identify 3 vulnerabilities of different types (e.g., SQL Injection, XSS, Path Traversal)
2. For each vulnerability, call `get_vulnerability_by_id` with its vulnID and appID
3. Compare the results to ensure each returns unique, correct data

**Expected Results**:
- Each call returns different vulnerability data
- Each vulnerability has the correct title, type, and ID
- No data leakage between calls

---

### Category 2: Validation and Error Handling

#### Test 2.1: Invalid Vulnerability ID
**Objective**: Verify appropriate error handling for non-existent vulnerability ID

**Prerequisites**:
- Assume at least one valid application exists in the system

**Test Steps**:
1. Identify a valid appID from the system
2. Generate an invalid/non-existent vulnID (e.g., "INVALID-VULN-ID-12345" or a random UUID)
3. Call `get_vulnerability_by_id` with the invalid vulnID and valid appID

**Expected Results**:
- Tool throws an IOException with message "Failed to retrieve vulnerability details"
- Error message should indicate the vulnerability was not found
- No partial data is returned

---

#### Test 2.2: Invalid Application ID
**Objective**: Verify appropriate error handling for non-existent application ID

**Prerequisites**:
- Assume at least one valid vulnerability exists in the system

**Test Steps**:
1. Identify a valid vulnID from the system
2. Generate an invalid/non-existent appID (e.g., "INVALID-APP-ID-67890" or a random UUID)
3. Call `get_vulnerability_by_id` with the valid vulnID and invalid appID

**Expected Results**:
- Tool throws an IOException or returns an error
- Error message should indicate the application or vulnerability was not found
- No partial data is returned

---

#### Test 2.3: Mismatched Vulnerability and Application IDs
**Objective**: Verify the tool correctly handles when a vulnerability ID exists but not in the specified application

**Prerequisites**:
- Assume vulnerabilities exist in at least 2 different applications (App A and App B)

**Test Steps**:
1. Identify a vulnerability in Application A (vulnID_A, appID_A)
2. Identify a different application B (appID_B)
3. Call `get_vulnerability_by_id` with vulnID_A and appID_B (mismatched pair)

**Expected Results**:
- Tool should fail to find the vulnerability or throw an error
- Should not return vulnerability data from the wrong application
- Error handling should be graceful

---

#### Test 2.4: Null or Empty Parameters
**Objective**: Verify parameter validation

**Test Steps**:
1. Call `get_vulnerability_by_id` with null vulnID
2. Call `get_vulnerability_by_id` with empty string vulnID ("")
3. Call `get_vulnerability_by_id` with null appID
4. Call `get_vulnerability_by_id` with empty string appID ("")

**Expected Results**:
- Each call should fail with appropriate error handling
- No NullPointerException should occur
- Error messages should be informative

---

### Category 3: Data Completeness

#### Test 3.1: Verify Recommendation Data
**Objective**: Verify recommendation text is retrieved and populated in howToFix field

**Prerequisites**:
- Assume vulnerabilities exist with recommendation data available

**Test Steps**:
1. Find a vulnerability that should have remediation recommendations
2. Call `get_vulnerability_by_id` with the vulnID and appID
3. Inspect the `howToFix` field in the response

**Expected Results**:
- `howToFix` field is not null
- `howToFix` contains meaningful recommendation text (length > 50 characters)
- Text should contain actionable remediation guidance

---

#### Test 3.2: Verify HTTP Request Data
**Objective**: Verify HTTP request data is retrieved and populated

**Prerequisites**:
- Assume vulnerabilities exist with HTTP request data (typically runtime vulnerabilities)

**Test Steps**:
1. Find a vulnerability that was triggered by an HTTP request (look for web application vulnerabilities)
2. Call `get_vulnerability_by_id` with the vulnID and appID
3. Inspect the `httpRequest` field in the response

**Expected Results**:
- `httpRequest` field is not null
- Contains HTTP request details (method, path, headers, etc.)
- Request text should be in readable format

**Note**: Some vulnerabilities may not have HTTP request data (e.g., static analysis findings). This test should specifically target runtime-detected vulnerabilities.

---

#### Test 3.3: Verify Stacktrace Data
**Objective**: Verify stacktrace information is retrieved and populated

**Prerequisites**:
- Assume vulnerabilities exist with stacktrace data from trigger events

**Test Steps**:
1. Find a vulnerability that should have stacktraces (runtime vulnerabilities typically have these)
2. Call `get_vulnerability_by_id` with the vulnID and appID
3. Inspect the `stackTrace` field in the response

**Expected Results**:
- `stackTrace` is not null and not empty
- Each StackLib entry contains:
  - `stackTraceLine`: non-empty string with code location/method information
  - `libraryHash`: either a valid hash string or null
- At least one stacktrace line should reference application or library code

---

#### Test 3.4: Verify Hint Data
**Objective**: Verify contextual hint is generated for the vulnerability

**Prerequisites**:
- Assume vulnerabilities exist in the system

**Test Steps**:
1. Find a vulnerability with a known type (e.g., SQL Injection, XSS)
2. Call `get_vulnerability_by_id` with the vulnID and appID
3. Inspect the `hint` field in the response

**Expected Results**:
- `hint` field is not null
- Contains contextual security guidance relevant to the vulnerability type
- Hint text is actionable and provides developer guidance

---

#### Test 3.5: Verify Timestamp Data
**Objective**: Verify all timestamp fields are properly populated

**Prerequisites**:
- Assume vulnerabilities exist with various statuses (open, closed)

**Test Steps**:
1. Find an open vulnerability
2. Call `get_vulnerability_by_id` and verify firstTimeSeen and lastTimeSeen are populated
3. Find a closed vulnerability
4. Call `get_vulnerability_by_id` and verify closedTime is populated

**Expected Results**:
- `firstTimeSeen` is a valid epoch timestamp (> 0)
- `lastTimeSeen` is a valid epoch timestamp >= firstTimeSeen
- For closed vulnerabilities, `closedTime` should be a valid epoch timestamp
- For open vulnerabilities, `closedTime` may be null or 0

---

### Category 4: Library Correlation

#### Test 4.1: Verify Library Matching with CVEs
**Objective**: Verify stacktraces are correctly matched to vulnerable libraries

**Prerequisites**:
- Assume vulnerabilities exist that have stacktraces referencing third-party libraries with known CVEs
- Ideally find a vulnerability where the issue is in a library, not application code

**Test Steps**:
1. Use `list_all_vulnerabilities` to find vulnerabilities that may be in third-party libraries (look for library-related types)
2. Call `get_vulnerability_by_id` for a vulnerability likely to involve a library
3. Inspect the `vulnerableLibraries` field
4. Inspect the `stackTrace` field to see library hash mappings

**Expected Results**:
- `vulnerableLibraries` list is not empty if the vulnerability involves a library with CVEs
- Each LibraryExtended object should contain:
  - Library name and version
  - Hash identifier
  - List of vulnerabilities/CVEs
- `stackTrace` entries should have non-null `libraryHash` values where the stacktrace references vulnerable library code
- The libraryHash in StackLib should match the hash of a library in vulnerableLibraries

---

#### Test 4.2: Verify Stacktrace Without Library Match
**Objective**: Verify stacktraces that don't match libraries have null libraryHash

**Prerequisites**:
- Assume vulnerabilities exist in application code (not third-party libraries)

**Test Steps**:
1. Find a vulnerability that is clearly in application code (not library code)
2. Call `get_vulnerability_by_id` with the vulnID and appID
3. Inspect the stackTrace entries

**Expected Results**:
- `stackTrace` list is not empty
- StackLib entries for application code should have `libraryHash` set to null
- Only stacktrace lines that reference vulnerable libraries should have non-null libraryHash

---

#### Test 4.3: Verify Library CVE Data Details
**Objective**: Verify CVE data is complete for vulnerable libraries

**Prerequisites**:
- Assume at least one vulnerability exists where the stacktrace references a library with known CVEs

**Test Steps**:
1. Find a vulnerability that involves a vulnerable third-party library
2. Call `get_vulnerability_by_id` with the vulnID and appID
3. Inspect each LibraryExtended object in vulnerableLibraries
4. Check the CVE/vulnerability details within each library

**Expected Results**:
- Each LibraryExtended should have a non-empty vulnerabilities list
- CVE data should include:
  - CVE identifier (e.g., CVE-2023-XXXXX)
  - Severity score
  - Description or title
- Library metadata should include name, version, and hash

---

#### Test 4.4: Verify Multiple Libraries in Single Vulnerability
**Objective**: Verify handling of vulnerabilities with stacktraces spanning multiple vulnerable libraries

**Prerequisites**:
- Assume a vulnerability exists where the call stack passes through multiple third-party libraries with CVEs

**Test Steps**:
1. Look for complex vulnerabilities that may involve multiple libraries
2. Call `get_vulnerability_by_id` with the vulnID and appID
3. Count the unique libraryHash values in stackTrace
4. Count the libraries in vulnerableLibraries

**Expected Results**:
- If stacktraces reference multiple vulnerable libraries, all should appear in vulnerableLibraries
- No duplicate libraries in vulnerableLibraries (Set ensures uniqueness)
- Each vulnerable library referenced in stacktraces should be included

---

### Category 5: Edge Cases and Special Scenarios

#### Test 5.1: Vulnerability Without HTTP Request Data
**Objective**: Verify handling when HTTP request data is not available

**Prerequisites**:
- Assume vulnerabilities exist that don't have associated HTTP requests (e.g., static analysis findings)

**Test Steps**:
1. Find a vulnerability that likely doesn't have HTTP request data
2. Call `get_vulnerability_by_id` with the vulnID and appID
3. Check the httpRequest field

**Expected Results**:
- Tool completes successfully without error
- `httpRequest` field is null or empty
- All other fields are still properly populated

---

#### Test 5.2: Vulnerability Without Stacktraces
**Objective**: Verify handling when stacktrace data is not available

**Prerequisites**:
- Assume some vulnerabilities may not have trigger events or stacktraces

**Test Steps**:
1. Find a vulnerability that may not have stacktrace data
2. Call `get_vulnerability_by_id` with the vulnID and appID
3. Check the stackTrace field

**Expected Results**:
- Tool completes successfully without error
- `stackTrace` field is an empty list (not null)
- `vulnerableLibraries` should also be empty since no libraries can be matched
- All other fields are still properly populated

---

#### Test 5.3: Large Stacktrace Volume
**Objective**: Verify handling of vulnerabilities with many stacktrace frames

**Prerequisites**:
- Assume vulnerabilities exist with deep call stacks (20+ frames)

**Test Steps**:
1. Find a vulnerability with a large number of stacktrace frames
2. Call `get_vulnerability_by_id` with the vulnID and appID
3. Count the stackTrace entries returned

**Expected Results**:
- All stacktrace frames are returned
- No truncation of stacktrace data
- Performance remains acceptable (< 15 seconds)
- Library matching is performed for all frames

---

#### Test 5.4: Recently Detected Vulnerability
**Objective**: Verify handling of newly detected vulnerabilities where data may still be processing

**Prerequisites**:
- Assume vulnerabilities are being actively detected in the system

**Test Steps**:
1. Identify the most recently detected vulnerability (highest lastTimeSeen timestamp)
2. Call `get_vulnerability_by_id` immediately
3. Check data completeness

**Expected Results**:
- Tool should handle new vulnerabilities gracefully
- All available data is returned
- If some data is still processing, relevant fields may be null/empty but tool should not error

---

### Category 6: Integration and Consistency

#### Test 6.1: Consistency with list_all_vulnerabilities
**Objective**: Verify data returned by get_vulnerability_by_id is consistent with summary data from list_all_vulnerabilities

**Prerequisites**:
- Assume vulnerabilities exist in the system

**Test Steps**:
1. Call `list_all_vulnerabilities` to get summary data for an application
2. Select a vulnerability from the list and note its vulnID, title, status, type
3. Call `get_vulnerability_by_id` with the vulnID and appID
4. Compare the common fields between both responses

**Expected Results**:
- `vulnID` matches exactly
- `title` matches exactly
- `status` matches exactly
- `type` matches exactly
- Timestamps should be consistent
- Detailed view should contain additional data not in the summary

---

#### Test 6.2: Verify Library Data Integration
**Objective**: Verify library data returned matches actual libraries in the application

**Prerequisites**:
- Assume the application has third-party libraries that can be queried separately

**Test Steps**:
1. Find a vulnerability with vulnerable libraries
2. Call `get_vulnerability_by_id` to get library CVE data
3. Verify the library exists in the application's dependency list
4. Cross-reference CVE data with known vulnerabilities for that library version

**Expected Results**:
- Libraries returned are actually used by the application
- CVE data matches the library version
- No false positives (libraries not in the app)

---

## Test Execution Guidelines

### Pre-Test Setup
1. Ensure the MCP server is running and properly configured with valid Contrast credentials
2. Verify network connectivity to the Contrast TeamServer
3. Confirm at least one application with vulnerabilities is available for testing
4. Have tools ready to query available data: `list_all_vulnerabilities`, `list_all_applications`

### Test Data Discovery
Before running tests, use these steps to discover suitable test data:
1. List all available applications to understand the landscape
2. Query vulnerabilities to find examples matching test requirements
3. Document vulnIDs and appIDs for reference during testing
4. Categorize vulnerabilities by type, status, and data richness

### Test Execution Order
1. Run Basic Functionality tests first to establish baseline
2. Run Data Completeness tests to understand available data
3. Run Library Correlation tests for integration verification
4. Run Validation and Error Handling tests for robustness
5. Run Edge Cases tests for corner scenario coverage
6. Run Integration tests for consistency validation

### Pass/Fail Criteria
- **Pass**: Expected results are met, no unexpected errors, data is valid and complete
- **Fail**: Tool throws unexpected errors, returns incorrect data, or data is malformed
- **Partial Pass**: Tool works but some optional fields are missing (document which ones)

### Documentation Requirements
For each test execution, document:
1. Test number and name
2. Actual vulnID and appID used
3. Full tool invocation (parameters)
4. Complete response received
5. Pass/fail status with reasoning
6. Any anomalies or unexpected behavior
7. Performance metrics (response time)

### Troubleshooting Guide
- **Connection Errors**: Verify Contrast credentials and network connectivity
- **Empty Results**: Confirm the test data exists using list tools
- **Timeout Issues**: Increase timeout settings or test with simpler vulnerabilities
- **Missing Data Fields**: Some fields may legitimately be null based on vulnerability type, document these cases

## Success Metrics
- At least 90% of applicable tests pass
- All critical functionality tests (Category 1 & 2) pass
- Data completeness tests pass for at least 70% of cases (some missing data is expected)
- No unhandled exceptions or crashes
- Response times are acceptable (< 10 seconds for typical requests)

## Notes for AI Test Executors
- Adapt test cases based on available data in the Contrast installation
- Document any test cases that cannot be executed due to lack of suitable test data
- If certain vulnerability types are not available, document which tests are skipped
- Use judgment to substitute similar test scenarios if exact prerequisites aren't met
- Focus on demonstrating the tool works correctly across the range of available data
