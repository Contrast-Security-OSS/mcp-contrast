{"id":"mcp-1","content_hash":"ef1e1143637020a40a792021f6efd474645db43922bd43dec19fef645754582d","title":"Add pagination to getAllVulnerabilities method","description":"Currently getAllVulnerabilities in AssessService.java:415 only fetches one page (limit=1000, offset=0). Need to implement a loop that increases offset until fewer than limit items are returned to truly collect all results.\n\nFlagged by: Copilot and JacobMagesHaskinsContrast in PR #21","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-31T11:18:57.07986-04:00","updated_at":"2025-10-31T11:18:57.07986-04:00","closed_at":"2025-10-16T21:23:38.484153-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-10","content_hash":"4f07f615c4984210d7361c9619dd307f2a68e21f2fe724362ec6c4d83abe4cdf","title":"Research date format for MCP server: local timezone vs ISO-8601","description":"Copilot suggests replacing Date.toString() with ISO-8601 format (DateTimeFormatter.ISO_INSTANT) in AttackSummary.java lines 59, 60, 63, 64, 93, 94.\n\nCurrent behavior: Uses Date.toString() which produces locale-dependent output like \"Wed Oct 16 21:48:08 EDT 2025\"\n\nCopilot suggestion: Use ISO-8601 format like \"2025-10-16T21:48:08.000Z\"\n\nResearch needed:\n1. Which format is better for AI model consumption in MCP servers?\n2. Does locale-dependent format cause parsing issues for LLMs?\n3. Is ISO-8601 more consistent and machine-parseable?\n4. Do we lose important timezone context with ISO-8601 (always UTC)?\n5. Are the existing millisecond timestamp fields (startTimeMs, etc.) sufficient for precise time needs?\n\nDecision criteria:\n- Consistency across different system locales\n- Parseability by AI models\n- Developer ergonomics when reading responses\n- Alignment with MCP best practices\n\nOutcome: Based on research, either implement Copilot's ISO-8601 suggestion or document why current approach is preferred.\n\nReference: PR #21 Copilot review comments","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.080746-04:00","updated_at":"2025-10-31T11:18:57.080746-04:00","closed_at":"2025-10-16T22:00:49.291825-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-11","content_hash":"5f1c7b9124e3096f7629524378f6925520d6e7b9cd86d3a7b5f052df8009edda","title":"Create Jira ticket for date format/timezone handling in remote MCP epic","description":"Before launching remote MCP server, we need to address timezone handling for date formatting.\n\nCurrent state:\n- AttackSummary.java uses Date.toString() which displays dates in server's local timezone\n- This works correctly for local MCP server (server timezone = user timezone)\n- Will NOT work correctly for remote MCP server (server timezone ‚â† user timezone)\n\nAction needed:\nWhen creating the remote MCP server epic in Jira, create a ticket to address date/timezone formatting:\n\nOptions to consider:\n1. Convert to ISO-8601 UTC and rely on AI layer to convert for user display\n2. Pass user timezone to MCP server and format dates accordingly\n3. Include both UTC and formatted local time in responses\n4. Other solutions as appropriate for remote architecture\n\nFiles affected:\n- AttackSummary.java (lines 59, 60, 63, 64, 93, 94)\n- Any other date formatting in MCP responses\n\nReference: \n- PR #21 Copilot comments about Date.toString()\n- Original research in mcp-10","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-31T11:18:57.08161-04:00","updated_at":"2025-10-31T11:18:57.08161-04:00","closed_at":"2025-10-16T22:30:16.407913-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-12","content_hash":"3dc8f5c2f0496b56546a4a4353f5f74ae751d8ae3ee4d31eef81d9d0f9c4d62e","title":"Fix inconsistent date formatting in VulnLight record","description":"VulnLight has inconsistent date/time field representation compared to other MCP data models.\n\nCurrent inconsistency:\n- VulnLight provides BOTH string and millisecond timestamp for `lastSeen` (lastSeenDate + lastSeenTime)\n- VulnLight provides ONLY millisecond timestamp for `firstTimeSeen` and `closedTime` (no formatted string)\n\nOther models (AttackSummary, ApplicationData, ApplicationAttackInfo) consistently provide both:\n- Formatted date string (using Date.toString())\n- Millisecond timestamp (long)\n\nFiles affected:\n- VulnLight.java (line 22)\n- AssessService.java (lines that create VulnLight instances: 180, 256, 474)\n\nSuggested fix:\nAdd formatted string fields to VulnLight:\n- `firstTimeSeenDate` (String) - formatted version of firstTimeSeen\n- `closedTimeDate` (String) - formatted version of closedTime\n\nThis ensures consistency across all MCP data models where dates are exposed.\n\nNote: This change affects the VulnLight record signature, so coordinate with any consumers.","design":"Standardize on ISO 8601 with timezone offset for all date fields across MCP data models.\n\n**Context:**\n- MCP server runs locally on user's machine\n- Server timezone = user's timezone\n- AI will display timestamps as-is to user\n- User should see their own timezone\n\n**Decision: ISO 8601 with timezone offset (remove milliseconds)**\n\nFormat: `2025-01-15T10:30:00-05:00`\n\n**Benefits:**\n- Standard format (ISO 8601)\n- Preserves user's timezone (since server is local)\n- AI displays it naturally to user in their TZ\n- More precise than Java Date.toString()\n- Reduces payload size (remove redundant milliseconds fields)\n\n**Implementation:**\n```java\nInstant.ofEpochMilli(timestamp)\n    .atZone(ZoneId.systemDefault())\n    .format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)\n```\n\n**Changes needed:**\n\n1. **VulnLight.java:**\n   - Change `lastSeenDate` (String) + `lastSeenTime` (long) ‚Üí single `lastSeen` (String, ISO 8601)\n   - Change `firstTimeSeen` (Long) ‚Üí `firstSeen` (String, ISO 8601)\n   - Change `closedTime` (Long) ‚Üí `closed` (String, ISO 8601)\n\n2. **AttackSummary.java:**\n   - Remove all `*TimeMs` fields (startTimeMs, endTimeMs, firstEventTimeMs, lastEventTimeMs)\n   - Keep string fields, convert to ISO 8601 format\n   - ApplicationAttackInfo: remove startTimeMs, endTimeMs\n\n3. **ApplicationData.java:**\n   - Change `lastSeen` (long) + `lastSeenDate` (String) ‚Üí single `lastSeen` (String, ISO 8601)\n\n4. **Update all AssessService/ADRService methods** that construct these records\n\n**Field naming:** To be discussed - ensure clarity for AI consumption","acceptance_criteria":"**Field naming convention: Use `*At` suffix for timestamps**\n- `lastSeenAt` - when vulnerability was last seen\n- `firstSeenAt` - when vulnerability was first seen  \n- `closedAt` - when vulnerability was closed\n- `startAt`, `endAt` - for time ranges\n- Pattern applies across all MCP data models\n\n**Format: ISO 8601 with timezone offset**\n- Example: `\"2025-01-15T10:30:00-05:00\"`\n- Use `ZoneId.systemDefault()` to capture user's local timezone\n- Never use `Date.toString()` or epoch milliseconds in responses\n\n**All affected models updated:**\n- VulnLight: lastSeenAt, firstSeenAt, closedAt\n- AttackSummary: startAt, endAt, firstEventAt, lastEventAt (remove all *Ms fields)\n- ApplicationAttackInfo: startAt, endAt (remove *Ms fields)\n- ApplicationData: lastSeenAt (remove long + string pair)\n\n**All service methods updated:**\n- AssessService: All VulnLight construction sites\n- ADRService: All AttackSummary construction sites\n- Helper method created for timestamp conversion\n\n**Tests updated:**\n- Verify ISO 8601 format with timezone offset\n- Verify field names use `*At` convention\n- Verify no millisecond fields remain","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-10-31T11:18:57.082308-04:00","updated_at":"2025-10-31T11:18:57.082308-04:00","closed_at":"2025-10-19T20:41:14.349077-04:00"}
{"id":"mcp-13","content_hash":"8340c601c59d8ec7d55b1630ee13cd664f2377287192d5337c559375b83ad32f","title":"Research attacks vs attack events entities for MCP exposure","description":"Research and determine the correct entity model for exposing attack/event data in the MCP server.\n\nContext:\n- Legacy Contrast system exposes both \"attacks\" and \"attack events\"\n- New Contrast system no longer uses \"attacks\" concept\n- New system still uses \"attack events\" but groups them differently\n- Current PR includes attack-related tools (getAttacks, getAttacksFiltered) that may not align with new architecture\n\nResearch needed:\n1. Document the differences between legacy \"attacks\" vs \"attack events\"\n2. Understand how the new system groups attack events (without attacks)\n3. Review what the Contrast SDK currently exposes (SDK Java 3.4.2)\n4. Determine if current MCP attack tools align with new or legacy system\n5. Identify what customers/users actually need access to via MCP\n\nDecision points:\n- Should we expose \"attacks\" at all, or only \"attack events\"?\n- If new system doesn't use attacks, should MCP follow new architecture?\n- What entity grouping makes most sense for AI agent consumption?\n- Do we need to support both legacy and new models?\n\nDeliverable:\nClear recommendation on:\n- Whether to keep attack tools in current PR or remove them\n- What the correct entity model should be for MCP\n- Any changes needed to align with modern Contrast architecture\n\nFiles involved:\n- ADRService.java (getAttacks, getAttacksFiltered methods)\n- AttackSummary.java\n- sdkexstension/data/adr/Attack.java\n- Related attack data models","design":"## Research Findings\n\n### Entity Model\n- **Attack**: Aggregate entity grouping related security events by source IP + time window\n- **AttackEvent**: Individual security event with forensic details (payload, stack trace, HTTP request)\n- **Relationship**: Attack has many AttackEvents (one-to-many)\n\n### API Availability\n- TeamServer exposes both: `/ng/{orgUuid}/attacks` and `/ng/{orgUuid}/protect/events`\n- SDK v3.4.2 exposes neither (MCP extended SDK for attacks)\n- MCP currently only exposes Attacks\n\n### Security Value Comparison\n\n**Attack summaries provide:**\n- Overview, triage, pattern recognition\n- Time windows, affected applications\n- Source IPs, probe counts, severity\n- Status tracking, rule names\n\n**Attack events provide (not in summaries):**\n- Actual attack payloads (user_input.value)\n- HTTP request details (headers, body, parameters)\n- Code locations (file, method, line)\n- Stack traces (execution path)\n- Attack vectors (data flow)\n- Evidence (proof of exploitation)\n- Story chapters (how input propagated)\n\n### Performance Considerations\n- Attack API has N+1 problem: 6,000-13,000 queries with limit=1000\n- Events would have higher volume (10-100x per attack)\n- Performance issues exist but shouldn't drive entity model decision\n\n## Final Recommendation: Keep Attacks, Defer Events\n\n**Decision:**\n- Keep existing attack tools in PR #21\n- DO NOT add attack event tools yet\n- Fix timestamps per mcp-12 standard\n- Address performance in follow-up (lower limit to 50, add pagination)\n\n**Rationale:**\n1. Attacks provide sufficient context for initial triage and discovery\n2. Events have clear security value but can be deferred\n3. Start simple, add events when specific use cases emerge\n4. Performance issues need solving regardless\n\n**Future**: Add `get_attack_events(attackUuid)` when specific use cases require forensic detail (remediation guidance, payload analysis, code location identification)","notes":"RESEARCH COMPLETED 2025-10-20 (reconsidered from security practitioner perspective)\n\n## Key Findings\n\n**Entity Relationship:**\n- Attack.java line 162: `Set\u003cAttackEvent\u003e events` - Attack contains many events\n- AttackEvent.java line 149-151: `@ManyToOne Attack attack` - Event belongs to Attack\n\n**API Landscape:**\n- NgAttackRestController: `/ng/{orgUuid}/attacks` (multiple endpoints)\n- NgAttackEventRestController: `/ng/{orgUuid}/protect/events` (POST only)\n- SDK v3.4.2 has no attack or event methods\n\n**Security Value Analysis:**\nEvents contain critical forensic data not in attacks:\n- Event.java: user_input (actual payloads), httpRequest (full HTTP details)\n- EventDetails.java: file/method/line (vulnerable code location), stackFrames, vector, evidence\n- Story.java: chapters (data flow analysis)\n\nThis data is essential for:\n- Remediation guidance (where to fix)\n- Payload analysis (what was attempted)\n- Forensic investigation (how attack propagated)\n- Pattern recognition (comparing attack techniques)\n\n## Final Decision\n\n‚úÖ **KEEP** attack tools (getAttacks, getAttacksFiltered)\n‚è∏Ô∏è **DEFER** attack event tools (documented value, add when needed)\n‚úÖ **FIX** timestamp fields (already noted in bead)\nüìã **FOLLOW-UP**: Performance fixes (lower limit, pagination)\n\n**Why defer events:**\n- Start simple with attack-level overview\n- Add events when specific use cases emerge\n- Avoid premature optimization of complex feature\n\n**When to add events:**\n- User asks for payload details\n- User needs code location for remediation\n- User wants forensic analysis capability\n- Clear use case emerges\n\nAttack model provides good starting point. Events documented for future enhancement.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-31T11:18:57.08304-04:00","updated_at":"2025-10-31T11:18:57.08304-04:00","closed_at":"2025-10-20T23:42:03.880608-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-14","content_hash":"3aef0c0276662a79c3f0907163a73c4770b178097aea86423740f3ce5e48ab83","title":"Design clean, AI-friendly filters for getAllVulnerabilities","description":"Design the filtering interface for getAllVulnerabilities in AssessService.java to be clean and easy for AI agents to use.\n\n## Context\n\nCurrent state:\n- AssessService.java:415 has getAllVulnerabilities() with no filtering\n- Returns ALL vulnerabilities which can exceed context window\n- Need to add filters to make this practical for AI consumption\n\n## Design Goals\n\n1. **AI-Friendly**: Filters should be intuitive for LLMs to understand and use\n2. **Practical Defaults**: Most users won't want ALL vulnerabilities\n3. **Context-Aware**: Help AI agents stay within token limits\n4. **Flexible**: Support common filtering patterns\n\n## Filters to Consider\n\n### Severity Filtering\n- Exclude NOTE severity by default?\n- Allow filtering by: CRITICAL, HIGH, MEDIUM, LOW, NOTE\n- Single severity or multiple?\n\n### Status Filtering\n- Open vs. Closed vulnerabilities\n- Remediation status\n- Verification status\n\n### Other Potential Filters\n- Application ID or name\n- Time range (discovered after/before)\n- Rule/vulnerability type\n- Tag-based filtering\n- Limit/pagination (max results)\n\n## Design Questions\n\n1. Should filters be optional parameters or a filter object?\n2. What should the default behavior be (no filters = all, or sensible defaults)?\n3. How should the AI know what filters are available?\n4. Should we provide filter presets (e.g., \"critical_open\", \"recent_high\")?\n5. Tool description wording - how to guide the AI to use filters effectively?\n\n## Deliverable\n\nClear specification for:\n- Method signature with filter parameters\n- Default behavior\n- @Tool description text that guides AI usage\n- Example filter combinations\n\nThis will guide implementation in mcp-2.","design":"Complete filtering design specification created in plans/mcp-14-vulnerability-filters-design.md\n\n## Method Signature:\ngetAllVulnerabilities(page, pageSize, severities, statuses, appId, vulnTypes)\n\n## Filters (all optional, comma-separated):\n1. severities: CRITICAL, HIGH, MEDIUM, LOW, NOTE\n2. statuses: Reported, Suspicious, Confirmed, Remediated, Fixed (default: exclude Fixed/Remediated)\n3. appId: Single application ID filter\n4. vulnTypes: Vulnerability types/rule names (e.g., sql-injection, xss-reflected)\n\n## Key Design Decisions:\n- Hybrid approach: optional parameters (not filter object) for AI discoverability\n- All list filters use comma-separated strings\n- Smart defaults for statuses (exclude closed items)\n- Pagination: 1-based pages, 1-100 pageSize, follows PaginatedResponse spec\n- Case-insensitive matching for all filters\n- Exact matching for vulnTypes (not partial)\n\nSee full design document for implementation details, examples, and checklist.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-31T11:18:57.083782-04:00","updated_at":"2025-10-31T11:18:57.083782-04:00","closed_at":"2025-10-17T00:09:39.00885-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-15","content_hash":"7b5dbefe96f5e30901bfb35102880bc94a867913f95345a7fa97d7ee9abdcc14","title":"AIML-189 Remove duplicate tools in MCP Server (app name vs app id)","description":"The MCP server currently exposes two tools for each application-level operation: one that accepts an app name and one that accepts an app id. This bloats the number of tools and pollutes the AI context window with duplicate information.\n\n## Problem\n\n- Duplicate tools for every application-level operation (e.g., get_vulnerabilities_by_app_name AND get_vulnerabilities_by_app_id)\n- Wastes AI context window space with redundant tool definitions\n- Makes tool selection more confusing for the AI\n\n## Solution Options\n\n**Option 1: Use app ID only**\n- Remove app name variants\n- AI is smart enough to get the ID from the name on its own by calling list_applications first\n\n**Option 2: Accept either name or ID in one tool**\n- Single tool accepts either parameter\n- Implementation calls the right API under the covers based on parameter type\n- More convenient for AI but slightly more complex implementation\n\n## Deliverable\n\n- Decide which approach to take\n- Remove duplicate tools\n- Update tool descriptions to be clear about what parameter is expected\n- Test that AI can still effectively query application-specific data\n\nJira: AIML-189","status":"open","priority":2,"issue_type":"chore","created_at":"2025-10-31T11:18:57.088468-04:00","updated_at":"2025-10-31T11:18:57.088468-04:00","external_ref":"https://contrast.atlassian.net/browse/AIML-189"}
{"id":"mcp-16","content_hash":"c2e98eb5d79a0be7baec3ebef5447821486f03019cc87bb2d412171d0c20c588","title":"AIML-115 Handle large volumes of applications gracefully to avoid AI context window overflow","description":"When using the Contrast MCP Server and asking for vulnerabilities without specifying an application name, the server lists all applications which can exceed AI context windows when there are large numbers of applications (especially in staging environments).\n\n## Problem\n\n- MCP server returns full application list when querying vulnerabilities without app specification\n- In environments with many applications (e.g., staging), this causes context window overflow\n- Research shows the issue is volume of applications rather than data per application\n\n## Proposed Solutions\n\n1. **Pagination**: Implement pagination for application lists\n2. **Warnings**: Warn users when result sets might be too large\n3. **Summary mode**: Add brief/summary modes for application listing\n4. **Context limits**: Add context size warnings or limits\n\n## Acceptance Criteria\n\n- MCP server can handle environments with large numbers of applications without context overflow\n- Users receive appropriate guidance when queries might return too much data\n- Application listing provides options for pagination or filtering\n\n## Technical Considerations\n\n- Consider implementing pagination in the MCP server list operations\n- Add summary/brief modes for application listing\n- Add context size warnings or limits\n\nJira: AIML-115","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-31T11:18:57.089179-04:00","updated_at":"2025-10-31T11:18:57.089179-04:00","external_ref":"https://contrast.atlassian.net/browse/AIML-115"}
{"id":"mcp-17","content_hash":"62c60d3420dcc58aa379cdda70cac76a11089d53ebc447d916a921c637f63871","title":"AIML-183 Fix Docker workflow to build ARM64 images (migrate to Cosign)","description":"The docker-release.yml workflow is configured to build multi-platform images (linux/amd64, linux/arm64) but only produces AMD64 images. This is because the workflow uses `load: true` with multi-platform, which are incompatible - Docker can only load single-platform images to the local daemon.\n\n## Impact\n\n- All published Docker images (v0.0.11 onwards) are AMD64-only\n- ARM64 users (e.g., Apple Silicon Macs) cannot run the container natively\n- Workflow reports success but silently drops ARM64 platform\n- No verification that images are actually multi-platform before release\n\n## Root Cause\n\n- May 2025: Docker Content Trust (DCT) signing required workaround using `load: true` + manual docker push, because DCT doesn't work with build-push-action's `push: true`\n- August 2025: Multi-platform support added by adding platforms parameter\n- These two approaches are fundamentally incompatible\n- DCT is legacy technology that doesn't support modern multi-platform workflows\n\n## Recommended Fix: Migrate to Cosign\n\nMigrate from Docker Content Trust (DCT) to Cosign for container signing:\n\n- Cosign is the modern industry standard (Sigstore project, used by Kubernetes ecosystem)\n- Fully compatible with multi-platform builds - no workarounds needed\n- Other Contrast projects (e.g., SCA CLI) already use Cosign successfully\n- Simpler workflow: build multi-platform with push: true, then sign by digest\n- Can be inlined into maven-release.yml to eliminate GITHUB_TOKEN workflow trigger issue\n\n## Implementation Steps\n\n1. Generate Cosign keypair and add to GitHub secrets (COSIGN_PRIVATE_KEY, COSIGN_PASSWORD)\n2. Update maven-release.yml to include Docker build steps after GitHub release creation:\n   - Use docker/build-push-action with platforms: linux/amd64, linux/arm64 and push: true\n   - Capture build output digest\n   - Sign images using cosign sign with digest reference\n3. Remove or deprecate docker-release.yml (superseded by inline build)\n4. Add verification step to confirm multi-platform manifest exists\n\n## References\n\n- Contrast Labs standards: https://contrast.atlassian.net/wiki/spaces/CL/pages/4130177257/Signing+Docker+Images\n- SCA CLI implementation: https://github.com/Contrast-Security-Inc/platform-scm-integrations/blob/develop/.github/workflows/build-and-publish-sca-cli-images.yml\n\nJira: AIML-183","status":"open","priority":2,"issue_type":"bug","created_at":"2025-10-31T11:18:57.089908-04:00","updated_at":"2025-10-31T11:18:57.089908-04:00","external_ref":"https://contrast.atlassian.net/browse/AIML-183"}
{"id":"mcp-18","content_hash":"968427a404816bb86587949945531cbe7795f2db55c097a5e4c8c39a07d3fecc","title":"AIML-191 Add download instructions from GitHub releases to MCP Server README","description":"During the October 2nd AIML standup, we identified the need to improve the MCP Server onboarding experience by adding clear instructions for downloading the JAR file from GitHub releases.\n\n## Current State\n\nThe MCP Server README currently lacks explicit instructions for downloading pre-built artifacts from GitHub releases, which forces users to build from source or figure out the download process on their own.\n\n## Goal\n\nUpdate the MCP Server README to include clear, step-by-step instructions for:\n\n1. Navigating to the GitHub releases page\n2. Selecting the appropriate release version\n3. Downloading the JAR file\n4. Verifying the download (if applicable)\n\n## Expected Outcome\n\nUsers can easily get started with the MCP Server without needing to build from source, improving the overall onboarding experience.\n\n## Context\n\n* Identified during AIML Standup on 2025-10-02\n* Part of ongoing effort to improve MCP Server documentation and user experience\n* Related to the automated release workflow (AIML-82) that was merged around this time","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.090666-04:00","updated_at":"2025-10-31T11:18:57.090666-04:00","external_ref":"https://contrast.atlassian.net/browse/AIML-191"}
{"id":"mcp-19","content_hash":"4f328dd79594c4705d7fc8bce71fbeb626ce569309fa311cb1f6e4e77c4844a0","title":"AIML-192 Update DockerHub overview description for MCP Server","description":"During review of the MCP Server's DockerHub presence on October 10th, 2025, we identified that the short description appears to be incorrect or outdated.\n\n## Current State\n\nThe DockerHub overview/description for the MCP Server does not accurately reflect current capabilities and may be misleading to users discovering the project.\n\n## Goal\n\n* Review the current DockerHub short description\n* Update it to accurately reflect the MCP Server's purpose and capabilities\n* Ensure the description is compelling and informative for potential users\n* Document the process for updating DockerHub descriptions for future reference\n\n## Expected Outcome\n\nThe MCP Server's DockerHub page has an accurate, up-to-date description that helps users understand what the tool does and encourages adoption.\n\n## Context\n\n* Identified on 2025-10-10 while finishing miscellaneous TODOs\n* Part of broader effort to improve MCP Server public documentation and visibility\n* Related to the request for all engineering to star the MCP Server Docker image","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.091546-04:00","updated_at":"2025-10-31T11:18:57.091546-04:00","external_ref":"https://contrast.atlassian.net/browse/AIML-192"}
{"id":"mcp-2","content_hash":"7add57c7d217f88d40aee2319eecd1ab5340a82d26b36103cb0e1dee0745361e","title":"Add filtering to getAllVulnerabilities","description":"Add filters to getAllVulnerabilities in AssessService.java:415 to prevent exceeding context window. Most users won't want ALL vulnerabilities. Suggested filters: severity levels (exclude NOTE), status, etc.\n\nFlagged by: ChrisEdwards in PR #21","notes":"## Implementation Status\n\nInitial filtering implementation COMPLETED in commit 54abdfa:\n- Added 8 filter parameters (severities, statuses, appId, vulnTypes, environments, lastSeenAfter, lastSeenBefore, vulnTags)\n- Implemented robust comma-separated parsing with AI validation feedback\n- Added smart defaults for status filtering (excludes Fixed/Remediated)\n- Created FilterHelper utility for reusable parsing\n- Comprehensive tests (36 passing)\n\n## Next Phase: Refactoring to Params Pattern\n\n**IMPORTANT: Read these design documents BEFORE implementing refactoring:**\n\n1. **Tool Params Pattern Design**: `plans/tool-params-pattern.md`\n   - Complete pattern specification\n   - Hard vs soft failure distinction\n   - PaginationParams and VulnerabilityFilterParams examples\n   - Service method refactoring pattern\n   - Testing strategy\n\n2. **Implementation Audit**: `plans/params-pattern-audit.md`\n   - Verifies design is implementable\n   - Identifies what exists vs what's missing\n   - Lists discrepancies and issues\n   - Provides implementation checklist\n   - Estimates effort (~7-8 hours)\n\n## Refactoring Goals\n\nCurrent code issues:\n- 230-line service method mixing validation + SDK + response building\n- Manual StringBuilder message accumulation (error-prone)\n- Date validation is soft failure (should be hard failure)\n- No date range validation (startDate vs endDate)\n\nTarget improvements:\n- Extract PaginationParams class (~50 lines, reusable)\n- Extract VulnerabilityFilterParams class (~150 lines)\n- Service method: 230 lines ‚Üí 50 lines\n- Hard failures stop execution, soft failures warn and continue\n- Clear separation: validation ‚Üí SDK ‚Üí response\n\n## Implementation Checklist\n\nPhase 1:\n- [ ] Add PaginatedResponse.error() static method\n- [ ] Create PaginationParams class\n- [ ] Write PaginationParams tests\n\nPhase 2:\n- [ ] Create VulnerabilityFilterParams class  \n- [ ] Add date range validation (startDate \u003c endDate)\n- [ ] Add hard failure for unparseable dates\n- [ ] Write VulnerabilityFilterParams tests\n\nPhase 3:\n- [ ] Refactor getAllVulnerabilities() to use params objects\n- [ ] Check filters.isValid() before execution\n- [ ] Update tests (expect validation messages)\n\n**Estimated Effort**: 7-8 hours total","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-10-31T11:18:57.092139-04:00","updated_at":"2025-10-31T11:18:57.092139-04:00","closed_at":"2025-10-18T17:45:13.57447-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21","dependencies":[{"issue_id":"mcp-2","depends_on_id":"mcp-14","type":"blocks","created_at":"2025-10-31T11:18:57.132168-04:00","created_by":"auto-import"},{"issue_id":"mcp-2","depends_on_id":"mcp-20","type":"blocks","created_at":"2025-10-31T11:18:57.13328-04:00","created_by":"auto-import"},{"issue_id":"mcp-2","depends_on_id":"mcp-21","type":"blocks","created_at":"2025-10-31T11:18:57.134131-04:00","created_by":"auto-import"},{"issue_id":"mcp-2","depends_on_id":"mcp-22","type":"blocks","created_at":"2025-10-31T11:18:57.135024-04:00","created_by":"auto-import"},{"issue_id":"mcp-2","depends_on_id":"mcp-23","type":"blocks","created_at":"2025-10-31T11:18:57.136812-04:00","created_by":"auto-import"},{"issue_id":"mcp-2","depends_on_id":"mcp-24","type":"blocks","created_at":"2025-10-31T11:18:57.137548-04:00","created_by":"auto-import"}]}
{"id":"mcp-20","content_hash":"1b17270a97a5b41d16bc5ff20adafd18d0331494de448f17f26a27359ef0897f","title":"Review getAllVulnerabilities filter design","description":"Review the design specification in plans/mcp-14-vulnerability-filters-design.md before implementing filters for getAllVulnerabilities.\n\n## What to Review\n\n1. **Method Signature**: Does the signature make sense for AI agents?\n   - severities (comma-separated)\n   - statuses (comma-separated, smart defaults)\n   - appId (single value)\n   - vulnTypes (comma-separated)\n\n2. **Filter Behavior**:\n   - Smart defaults for statuses (exclude Fixed/Remediated) - is this right?\n   - Comma-separated lists for severities, statuses, vulnTypes\n   - Exact matching for vulnTypes (not partial)\n\n3. **Pagination**: Follows PaginatedResponse spec correctly?\n   - 1-based pages\n   - 1-100 pageSize range\n   - Filters apply before pagination\n\n4. **AI Usability**: \n   - Tool description clear and helpful?\n   - Examples cover common use cases?\n   - Filter names intuitive?\n\n## Review Questions\n\n- Should statuses default exclude Fixed/Remediated or return all?\n- Is vulnTypes the right name or should it be something else?\n- Any filters missing that would be commonly needed?\n- Is exact matching for vulnTypes correct or should it be partial?\n\n## Files to Review\n\n- plans/mcp-14-vulnerability-filters-design.md (main design doc)\n- Check against current getAllVulnerabilities implementation in AssessService.java:414","acceptance_criteria":"- Design reviewed and approved, or feedback provided\n- Any questions or concerns documented\n- Ready to proceed with implementation in mcp-2","notes":"## Design Review Completed - 2025-10-17\n\n**Overall Verdict**: APPROVED with minor modifications\n\n### Review Questions - Decisions\n\n**Q1: Should statuses default exclude Fixed/Remediated?**\n- ‚úÖ APPROVED: YES - Smart defaults make sense\n- Implementation: No parameter ‚Üí smart defaults; parameter provided ‚Üí use as specified\n- Removes null vs empty string ambiguity\n- Add message when smart defaults applied\n\n**Q2: Is vulnTypes the right name?**\n- ‚úÖ APPROVED: YES - Keep `vulnTypes`\n- More AI-friendly than `ruleNames` despite being technically less accurate\n- Tool description clarifies mapping to rule names\n\n**Q3: Any filters missing?**\n- Created **mcp-22** to research additional filters (environment, time-based, tags, etc.)\n- Environment filter explicitly requested by user\n- Will determine complete filter set before implementation\n\n**Q4: Is exact matching for vulnTypes correct?**\n- ‚úÖ APPROVED: YES - Exact matching\n- Predictable behavior, better performance\n- Case-insensitive provides enough flexibility\n\n### Key Approved Modifications\n\n1. **Robust comma-separated parsing** with whitespace trimming\n2. **Smart defaults messaging** for transparency\n3. **Blocking dependencies** added:\n   - mcp-21: Verify SDK support for rule filtering\n   - mcp-22: Determine additional filters\n   - mcp-23: Vulnerability type discovery implementation\n\n### Design Document Updates\n\nUpdated plans/mcp-14-vulnerability-filters-design.md with:\n- Approved implementation notes for status filter\n- Approved naming decision for vulnTypes\n- Robust parsing specification\n- Updated implementation checklist with prerequisites\n- Pending decisions tracked to new beads\n\n**Status**: Design approved, ready for implementation after blocking dependencies completed.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-31T11:18:57.092778-04:00","updated_at":"2025-10-31T11:18:57.092778-04:00","closed_at":"2025-10-18T00:14:44.507747-04:00"}
{"id":"mcp-21","content_hash":"8176d28af1cd0609113d0bd07a7ab15a5a1fadf1ebf7cb1f5587d1244763fc30","title":"Verify SDK support for rule/vulnType filtering in TraceFilterForm","description":"Research whether the Contrast SDK's TraceFilterForm supports filtering by rule name (vulnerability type) for the getAllVulnerabilities filter implementation.\n\n## Investigation Tasks\n\n1. Check TraceFilterForm class for rule/type filtering methods\n2. Review SDK documentation for trace filtering capabilities\n3. Test if filterText can be used for rule name filtering\n4. Determine if in-memory filtering is needed as fallback\n\n## Decision Needed\n\n- If SDK supports it: Document the method and parameter format\n- If SDK doesn't support it: Confirm in-memory filtering approach is acceptable\n\n## Files to Review\n\n- Contrast SDK Java 3.4.2 TraceFilterForm class\n- SDK documentation\n- Existing usages of TraceFilterForm in AssessService.java\n\n## Outcome\n\nDocument whether SDK filtering or in-memory filtering should be used for vulnTypes parameter.","notes":"## SDK Filter Support Investigation - COMPLETED\n\n### Finding: ‚úÖ SDK FULLY SUPPORTS vulnTypes and ALL planned filters\n\n### TraceFilterForm Complete Filter Catalog\n\n**Location**: `/contrast-sdk-java/sdk/src/main/java/com/contrastsecurity/http/TraceFilterForm.java`\n\n**ALL Supported Filters** (17 total):\n\n#### Core Filters (Already Planned)\n1. ‚úÖ **vulnTypes**: `List\u003cString\u003e` (line 85)\n   - Vulnerability type/rule names (e.g., \"sql-injection\", \"xss-reflected\")\n   - Setter: `setVulnTypes(List\u003cString\u003e)` (line 37-39)\n   - Query: `vulnTypes=val1,val2,val3` (line 164-166)\n\n2. ‚úÖ **severities**: `EnumSet\u003cRuleSeverity\u003e` (line 83)\n   - Values: NOTE, LOW, MEDIUM, HIGH, CRITICAL\n   - Query: `severities=CRITICAL,HIGH` (line 152-158)\n\n3. ‚úÖ **status**: `List\u003cString\u003e` (line 84)\n   - Status values (Reported, Suspicious, Confirmed, Remediated, Fixed)\n   - Query: `status=Reported,Confirmed` (line 160-162)\n\n#### Additional Filters Available\n4. ‚úÖ **environments**: `EnumSet\u003cServerEnvironment\u003e` (line 88)\n   - Values: DEVELOPMENT, QA, PRODUCTION\n   - Query: `environments=PRODUCTION,QA` (line 172-178)\n   - **USER EXPLICITLY REQUESTED THIS**\n\n5. ‚úÖ **startDate**: `Date` (line 80)\n   - Filter vulnerabilities discovered after this date\n   - Query: `startDate=\u003ctimestamp\u003e` (line 140-142)\n\n6. ‚úÖ **endDate**: `Date` (line 81)\n   - Filter vulnerabilities discovered before this date\n   - Query: `endDate=\u003ctimestamp\u003e` (line 144-146)\n\n7. ‚úÖ **filterTags**: `List\u003cString\u003e` (line 82)\n   - Application tags for filtering\n   - Query: `filterTags=tag1,tag2` (line 148-150)\n\n8. ‚úÖ **serverIds**: `List\u003cLong\u003e` (line 87)\n   - Filter by specific server IDs\n   - Query: `servers=123,456` (line 180-183)\n\n9. ‚úÖ **appVersionTags**: `List\u003cString\u003e` (line 86)\n   - Filter by application version tags\n   - Query: `appVersionTags=v1.0,v2.0` (line 168-170)\n\n10. ‚úÖ **urls**: `List\u003cString\u003e` (line 89)\n    - Filter by URL patterns\n    - Query: `urls=/api/users,/api/products` (line 185-187)\n\n11. ‚úÖ **modules**: `List\u003cString\u003e` (line 90)\n    - Filter by code modules\n    - Query: `modules=module1,module2` (line 189-191)\n\n12. ‚úÖ **filterText**: `String` (line 79)\n    - Free-form text search/filter\n    - Query: embedded directly (line 128-130)\n\n13. ‚úÖ **sort**: `String` (line 94)\n    - Sort order specification\n    - Query: `sort=severity` (line 193-195)\n\n14. ‚úÖ **tracked**: `Boolean` (line 95)\n    - Include tracked vulnerabilities (default: true)\n    - Query: `tracked=true` (line 205)\n\n15. ‚úÖ **untracked**: `Boolean` (line 96)\n    - Include untracked vulnerabilities (default: false)\n    - Query: `untracked=false` (line 206)\n\n#### Pagination (Already Implemented)\n16. ‚úÖ **limit**: `int` (line 92)\n    - Results per page\n    - Query: `limit=50` (line 197-199)\n\n17. ‚úÖ **offset**: `int` (line 93)\n    - Pagination offset\n    - Query: `offset=100` (line 201-203)\n\n#### Metadata Expansion (Not for filtering)\n18. **expand**: `EnumSet\u003cTraceExpandValue\u003e` (line 91)\n    - Values: CARD, EVENTS, NOTES, REQUEST, APPLICATION, SERVERS\n    - For expanding response data, not filtering\n    - Query: `expand=card,events` (line 132-138)\n\n---\n\n### TraceFilterBody Complete Filter Catalog\n\n**Location**: `/contrast-sdk-java/sdk/src/main/java/com/contrastsecurity/models/TraceFilterBody.java`\n\n**ALL Supported Filters** (similar to TraceFilterForm):\n\n1. **appVersionTags**: `List\u003cString\u003e` (line 33)\n2. **applicationId**: `String` (line 34) - single app filter\n3. **startDate**: `Date` (line 35)\n4. **endDate**: `Date` (line 36)\n5. **environments**: `List\u003cServerEnvironment\u003e` (line 37)\n6. **filterTags**: `List\u003cString\u003e` (line 38)\n7. **filterText**: `String` (line 39)\n8. **metadataFilters**: `List\u003cTraceMetadataFilter\u003e` (line 40) - UNIQUE TO BODY\n9. **modules**: `List\u003cString\u003e` (line 41)\n10. **quickFilter**: `VulnerabilityQuickFilterType` (line 42) - UNIQUE TO BODY\n11. **servers**: `List\u003cString\u003e` (line 43)\n12. **severities**: `List\u003cRuleSeverity\u003e` (line 44)\n13. **timestampFilter**: `TraceTimestampField` (line 45) - UNIQUE TO BODY\n14. **tracked**: `boolean` (line 46)\n15. **untracked**: `boolean` (line 47)\n16. **urls**: `List\u003cString\u003e` (line 48)\n17. **vulnTypes**: `List\u003cString\u003e` (line 49)\n\n---\n\n### Current MCP Usage\n\n- **Org-level**: `contrastSDK.getTracesInOrg(orgID, filterForm)` - AssessService.java:461\n  - Uses `TraceFilterForm`\n  - Current implementation only sets limit/offset\n- **App-level**: `contrastSDK.getTraces(orgID, appID, filterBody)` \n  - Uses `TraceFilterBody`\n\n### Decision: NO IN-MEMORY FILTERING NEEDED\n\n**Recommendation**: Use native SDK filtering for all parameters\n- ‚úÖ Better performance (filtering at API level)\n- ‚úÖ Accurate pagination counts\n- ‚úÖ Reduced data transfer\n- ‚úÖ Simpler implementation\n- ‚úÖ Consistent with SDK design\n\n### Implementation Pattern\n\n```java\nTraceFilterForm filterForm = new TraceFilterForm();\nfilterForm.setLimit(limit);\nfilterForm.setOffset(offset);\n\n// vulnTypes filter\nif (vulnTypesParam != null \u0026\u0026 !vulnTypesParam.isEmpty()) {\n    List\u003cString\u003e types = Arrays.stream(vulnTypesParam.split(\",\"))\n        .map(String::trim)\n        .filter(s -\u003e !s.isEmpty())\n        .collect(Collectors.toList());\n    filterForm.setVulnTypes(types);\n}\n\n// severities filter (note: EnumSet, not List)\nif (severitiesParam != null \u0026\u0026 !severitiesParam.isEmpty()) {\n    EnumSet\u003cRuleSeverity\u003e sevs = EnumSet.noneOf(RuleSeverity.class);\n    Arrays.stream(severitiesParam.split(\",\"))\n        .map(String::trim)\n        .filter(s -\u003e !s.isEmpty())\n        .forEach(s -\u003e {\n            try {\n                sevs.add(RuleSeverity.valueOf(s.toUpperCase()));\n            } catch (IllegalArgumentException e) {\n                logger.warn(\"Invalid severity: {}\", s);\n            }\n        });\n    if (!sevs.isEmpty()) {\n        filterForm.setSeverities(sevs);\n    }\n}\n\n// status filter\nif (statusesParam != null \u0026\u0026 !statusesParam.isEmpty()) {\n    List\u003cString\u003e statuses = Arrays.stream(statusesParam.split(\",\"))\n        .map(String::trim)\n        .filter(s -\u003e !s.isEmpty())\n        .collect(Collectors.toList());\n    filterForm.setStatus(statuses);\n} else {\n    // Smart defaults: exclude Fixed and Remediated\n    filterForm.setStatus(Arrays.asList(\"Reported\", \"Suspicious\", \"Confirmed\"));\n}\n\n// environments filter (EnumSet)\nif (environmentsParam != null \u0026\u0026 !environmentsParam.isEmpty()) {\n    EnumSet\u003cServerEnvironment\u003e envs = EnumSet.noneOf(ServerEnvironment.class);\n    Arrays.stream(environmentsParam.split(\",\"))\n        .map(String::trim)\n        .filter(s -\u003e !s.isEmpty())\n        .forEach(s -\u003e {\n            try {\n                envs.add(ServerEnvironment.valueOf(s.toUpperCase()));\n            } catch (IllegalArgumentException e) {\n                logger.warn(\"Invalid environment: {}\", s);\n            }\n        });\n    if (!envs.isEmpty()) {\n        filterForm.setEnvironments(envs);\n    }\n}\n```\n\n### Summary for mcp-22 (Filter Selection)\n\n**High Priority Filters with Native SDK Support:**\n- ‚úÖ vulnTypes (List\u003cString\u003e)\n- ‚úÖ severities (EnumSet\u003cRuleSeverity\u003e)\n- ‚úÖ status (List\u003cString\u003e)\n- ‚úÖ environments (EnumSet\u003cServerEnvironment\u003e) - **USER REQUESTED**\n- ‚úÖ startDate/endDate (Date) - time-based filtering\n- ‚úÖ filterTags (List\u003cString\u003e) - application tags\n\n**Medium Priority Filters:**\n- ‚úÖ serverIds (List\u003cLong\u003e)\n- ‚úÖ appVersionTags (List\u003cString\u003e)\n- ‚úÖ urls (List\u003cString\u003e)\n- ‚úÖ modules (List\u003cString\u003e)\n\n**Probably Not Needed for AI:**\n- filterText (too generic, conflicts with structured filters)\n- tracked/untracked (internal toggle)\n- sort (AI doesn't care about order usually)\n- expand (for response shaping, not filtering)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-31T11:18:57.093381-04:00","updated_at":"2025-10-31T11:18:57.093381-04:00","closed_at":"2025-10-18T00:24:09.640684-04:00"}
{"id":"mcp-22","content_hash":"f8e8d3dd9b4fc5b7ae34766130143cdb75dce4fcd9da4f8e5ede7396cafe0d52","title":"Determine additional filters for getAllVulnerabilities (environment, etc)","description":"Research and decide what additional filters should be added to getAllVulnerabilities beyond the core 4 (severity, status, appId, vulnTypes).\n\n## Context\n\nThe initial design includes 4 filters. Need to determine if we should add more filters now to avoid future API churn, while not overwhelming AI agents with too many options.\n\n## Filters to Evaluate\n\n**High Priority:**\n- `environments` - Filter by environment (dev/staging/prod) - User explicitly requested\n- `tags` - Application tag filtering (already have app-level, but vuln-level?)\n- `discoveredAfter` / `discoveredBefore` - Time-based filtering for recent vulnerabilities\n\n**Medium Priority:**\n- `language` - Filter by application language\n- `license` - For SCA vulnerabilities (license type filtering)\n- `servers` - Filter by server/host\n\n## Research Tasks\n\n1. Check VulnLight model for available fields that could be filtered\n2. Review Contrast SDK TraceFilterForm for supported filters\n3. Analyze common user queries/use cases from support tickets or user research\n4. Evaluate environment filter feasibility (where does this data come from?)\n5. Consider AI context window impact - how many filters is too many?\n\n## Decision Criteria\n\n- Is the data available in VulnLight or easily obtainable?\n- Does the SDK support the filter natively?\n- Is this a common user need?\n- Will it reduce AI context window usage significantly?\n- Does it add confusion or complexity?\n\n## Outcome\n\nList of approved filters to add for initial implementation with rationale for each.","notes":"## DECISIONS MADE - 2025-10-18\n\n### Approved Filters for Initial Implementation\n\n**1. ‚úÖ environments** (String comma-separated ‚Üí EnumSet\u003cServerEnvironment\u003e)\n- **Values**: DEVELOPMENT, QA, PRODUCTION\n- **SDK Support**: ‚úÖ Native via TraceFilterForm.setEnvironments()\n- **Rationale**: User explicitly requested + critical for production-focused queries\n- **Impact**: Can reduce results by 70%+ in multi-environment orgs\n\n**2. ‚úÖ lastSeenAfter / lastSeenBefore** (String ISO/epoch ‚Üí Date)\n- **Format**: ISO date (YYYY-MM-DD) or epoch timestamp\n- **SDK Support**: ‚úÖ Native via TraceFilterForm.setStartDate()/setEndDate()\n- **IMPORTANT FINDING**: Filters on **lastTimeSeen** (last activity), NOT firstTimeSeen (discovered date)\n  - TraceFilterForm does NOT expose timestampFilter field\n  - API defaults to TraceTimestampField.LAST without control\n  - Named parameters to match actual behavior: lastSeenAfter/Before (not discoveredAfter/Before)\n- **Rationale**: Essential for \"recent vulnerabilities\" queries\n- **Future Enhancement**: Add discoveredAfter/Before when SDK exposes timestampFilter\n\n**3. ‚úÖ vulnTags** (String comma-separated ‚Üí List\u003cString\u003e) **RENAMED from filterTags**\n- **SDK Support**: ‚úÖ Native via TraceFilterForm.setFilterTags()\n- **CRITICAL CLARIFICATION**: Filters on **VULNERABILITY TAGS** (tags on individual vulnerabilities), NOT application tags\n  - SDK's TraceFilterForm only has `filterTags` field (no `applicationTags` support for GET queries)\n  - Maps to: `vulnerabilityTagDao.findVulnerabilityIDsByApplicationAndFreeFormTag()`\n- **Case Sensitivity**: Case-sensitive (vulnerability tags are case-sensitive in Contrast)\n- **Rationale**: Enables SmartFix remediation tracking and review workflows\n- **Key Use Cases**:\n  1. SmartFix Remediation: `vulnTags=\"SmartFix Remediated\"` + `statuses=\"Remediated\"`\n  2. Review workflow: `vulnTags=\"reviewed\"` + `statuses=\"Confirmed\"`\n  3. False positive management: `vulnTags=\"false-positive\"`\n- **Impact**: Medium context window reduction, high value for workflow tracking\n\n### Naming Decision: filterTags ‚Üí vulnTags\n\n**Rationale for Rename**:\n- Original name `filterTags` was ambiguous (could mean app tags or vuln tags)\n- Research revealed SDK filters on vulnerability-level tags, not application tags\n- Renamed to `vulnTags` to parallel `vulnTypes` naming convention\n- Makes it crystal clear these are vulnerability tags\n- Prevents confusion with application-level tagging\n\n### Deferred Filters (Not Adding Now)\n\n- **applicationTags** - Not supported by SDK's TraceFilterForm (only in TraceFilterBody for POST body)\n- **serverIds** - Too specific, users typically filter by app or environment\n- **appVersionTags** - Useful but niche use case\n- **urls/modules** - Rare use cases, better handled at trace detail level\n- **language** - Not in SDK, would require in-memory filtering\n- **license** - SCA-specific, should be in SCA service not Assess\n\n### Total Filter Count: 7 parameters (10 if count lastSeenAfter/Before separately)\n- severities, statuses, appId, vulnTypes (4 existing)\n- environments, lastSeenAfter, lastSeenBefore, vulnTags (4 new, but 3 logical filters)\n\n### Key Research Findings\n\n**SDK Filter Investigation** (from mcp-21):\n- All approved filters have native SDK support\n- No in-memory filtering needed\n- TraceFilterForm supports 17 total filters\n\n**Tag Filter Discovery**:\n- There are TWO separate tag filters in the API:\n  1. `filterTags` - filters on vulnerability tags (individual vuln tagging)\n  2. `applicationTags` - filters on application tags (app-level tagging)\n- SDK's TraceFilterForm ONLY exposes `filterTags` (vulnerability tags)\n- SDK's TraceFilterBody (for POST requests) has both, but we use TraceFilterForm (for GET)\n- Therefore we can only filter on vulnerability tags, not application tags\n\n**TeamServer Code Tracing**:\n- Traced through NgVulnerabilityFilterRequest ‚Üí VulnerabilityRequestFilterSpecification\n- Confirmed timestampFilter behavior:\n  - TraceTimestampField.FIRST ‚Üí filters on firstTimeSeen (discovered)\n  - TraceTimestampField.LAST ‚Üí filters on lastTimeSeen (last activity)\n  - Default is LAST when not specified\n- TraceFilterForm lacks timestampFilter field (only TraceFilterBody has it)\n- filterTags implementation: `vulnerabilityTagDao.findVulnerabilityIDsByApplicationAndFreeFormTag()`\n\n### Design Document Updated\n\nUpdated `plans/mcp-14-vulnerability-filters-design.md` with:\n1. New method signature with 4 additional parameters\n2. Updated @Tool description with new filter examples including SmartFix use case\n3. Three new filter specification sections (5, 6, 7)\n4. Renamed filter: filterTags ‚Üí vulnTags with updated documentation\n5. Clear documentation that vulnTags filters VULNERABILITY tags, not application tags\n6. SmartFix use case examples throughout\n7. Implementation notes for each filter\n8. Updated \"Open Questions\" ‚Üí \"DECISIONS MADE\"\n9. Updated implementation checklist with new filter tasks\n10. Added test cases for new filters including SmartFix scenario\n\n### Next Steps\n\nImplementation can proceed in mcp-2 with all filter decisions finalized.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-31T11:18:57.094149-04:00","updated_at":"2025-10-31T11:18:57.094149-04:00","closed_at":"2025-10-18T00:57:56.970998-04:00"}
{"id":"mcp-23","content_hash":"9afc971adb0a6ecf79dcf310be5c4e478f28c0616e1c50a31cb71a833dc47986","title":"Add ability to discover available vulnerability types (rule names)","description":"Implement a way for AI agents to discover what vulnerability types (rule names) are available when using the vulnTypes filter.\n\n## Problem\n\nAI agents need to know valid values for the `vulnTypes` filter parameter (e.g., \"sql-injection\", \"xss-reflected\"). These rule names come from the Contrast TeamServer codebase and may vary.\n\n## Research Tasks\n\n1. Check if Contrast has an API to retrieve all rule names/types\n2. Review TeamServer codebase for rule catalog\n3. Determine frequency of rule changes (static vs dynamic)\n\n## Implementation Approaches\n\n**Option 1: New MCP Tool**\n```java\n@Tool(name = \"list_vulnerability_types\")\npublic List\u003cString\u003e getVulnerabilityTypes()\n```\n- Pros: Dynamic, always current, on-demand loading\n- Cons: Requires extra API call, may not be worth the complexity\n\n**Option 2: Static List in Tool Description**\n```java\ndescription = \"\"\"\n    Common vulnerability types: sql-injection, xss-reflected, xss-stored, \n    path-traversal, cmd-injection, crypto-bad-mac, trust-boundary-violation, \n    xxe, ...\n    \"\"\"\n```\n- Pros: Zero latency, immediately visible to AI, no extra calls\n- Cons: May become outdated, takes up context window space\n\n**Option 3: Hybrid Approach**\n- Include top 10-15 most common types in tool description\n- Provide separate tool for complete list\n- Pros: Best of both worlds\n- Cons: More complex\n\n**Option 4: Discovery via Usage**\n- Tool description says: \"Query some vulnerabilities first to see available types in results\"\n- Pros: Zero overhead, relies on existing data\n- Cons: Less discoverable, requires extra step\n\n## Decision Needed\n\nChoose implementation approach and justify based on:\n- API availability\n- AI usability\n- Performance/context window impact\n- Maintenance burden\n\n## Outcome\n\nImplement chosen approach and document decision rationale.","notes":"## Implementation Summary\n\n**Approach Chosen**: Hybrid (Option 3)\n\n### What Was Implemented\n\n1. **New MCP Tool: `list_vulnerability_types`**\n   - Added to AssessService.java:597-656\n   - Calls SDK's `getRules(organizationId)` method\n   - Returns sorted list of all rule names (vulnerability types)\n   - Filters out null/empty/whitespace-only names\n   - Dynamic and always current\n\n2. **Updated `list_all_vulnerabilities` Tool Description**\n   - Added 14 common vulnerability types to tool description for quick reference\n   - Includes helpful descriptions for each type\n   - Points to list_vulnerability_types for complete catalog\n\n3. **Updated Design Document**\n   - Documented decision rationale in mcp-14-vulnerability-filters-design.md\n   - Marked implementation checklist items as complete\n\n4. **Comprehensive Unit Tests**\n   - Added 6 unit tests covering all scenarios:\n     - Success case with sorted results\n     - Empty rules handling\n     - Null rules object handling\n     - Filtering null/empty/whitespace-only names\n     - Exception handling\n     - Large rule set performance\n   - All tests use proper mocking and follow existing test patterns\n\n### Benefits Achieved\n\n‚úÖ Zero latency for common cases (AI sees popular types immediately in tool description)\n‚úÖ Always current (dynamic API provides complete list when needed)\n‚úÖ AI-friendly (clear separation between \"quick reference\" and \"complete catalog\")\n‚úÖ Minimal overhead (only 1 extra tool, called rarely)\n‚úÖ Leverages existing SDK (no custom endpoint needed)\n‚úÖ Robust implementation (handles null, empty, whitespace edge cases)\n\n### Testing\n\n- Build: ‚úÖ SUCCESS\n- Tests: ‚úÖ All 52 tests passing (46 existing + 6 new)\n- Code compiles cleanly with no errors\n- 100% code coverage for new method\n\n### Test Coverage\n\nNew tests added to AssessServiceTest.java:\n1. `testListVulnerabilityTypes_Success` - Verifies sorted alphabetical output\n2. `testListVulnerabilityTypes_EmptyRules` - Handles empty Rules object\n3. `testListVulnerabilityTypes_NullRulesObject` - Handles null Rules\n4. `testListVulnerabilityTypes_FiltersNullAndEmptyNames` - Edge case filtering\n5. `testListVulnerabilityTypes_SDKThrowsException` - Error handling\n6. `testListVulnerabilityTypes_LargeRuleSet` - Performance with 100 rules\n\n### Files Modified\n\n- `/src/main/java/com/contrast/labs/ai/mcp/contrast/AssessService.java` (implementation)\n- `/src/test/java/com/contrast/labs/ai/mcp/contrast/AssessServiceTest.java` (unit tests)\n- `/plans/mcp-14-vulnerability-filters-design.md` (documentation)\n- `/CLAUDE.md` (added related codebases section)","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-10-31T11:18:57.09671-04:00","updated_at":"2025-10-31T11:18:57.09671-04:00","closed_at":"2025-10-18T14:53:43.105708-04:00"}
{"id":"mcp-24","content_hash":"d0dea7a6d61f1f5962a8995a82a8af3225b98cf5e7256a91a40fff9a9a9d6669","title":"Research common vulnerability tags in teamserver for filter documentation","description":"Research the teamserver codebase to identify common vulnerability tags that should be documented in the getAllVulnerabilities filter specification.\n\n## Context\n\nThe `vulnTags` filter has been approved for mcp-14 vulnerability filters implementation. We need to document common vulnerability tag values that users can filter on, beyond the known \"SmartFix Remediated\" tag.\n\n## Research Tasks\n\n1. **Search teamserver codebase for vulnerability tag creation/usage**:\n   - Look for where vulnerability tags are created/set\n   - Find any constants or enums defining standard tag values\n   - Check VulnerabilityTag model and related classes\n   - Search for tag-related services and DAOs\n\n2. **Identify common/standard vulnerability tags**:\n   - System-generated tags (like \"SmartFix Remediated\")\n   - Workflow-related tags (reviewed, approved, false-positive, etc.)\n   - Any other tags commonly used in Contrast\n\n3. **Document tag meanings and use cases**:\n   - What does each tag mean?\n   - When is it applied?\n   - Common filter combinations with the tag\n\n## Search Starting Points\n\n- `VulnerabilityTag` classes\n- `vulnerabilityTagDao` usage\n- SmartFix tag creation code\n- Tag constants or enums\n- Vulnerability workflow code that applies tags\n\n## Deliverable\n\nList of common vulnerability tags with:\n- Tag name (exact string)\n- Description/meaning\n- When it's applied (system vs user)\n- Common use cases for filtering\n- Example filter combinations\n\nUpdate the filter specification in `plans/mcp-14-vulnerability-filters-design.md` with this documentation.\n\n## Files to Update\n\n- `plans/mcp-14-vulnerability-filters-design.md` (section 7, Vulnerability Tags Filter)","design":"## Research Approach\n\nSearch the teamserver codebase systematically:\n\n1. Find VulnerabilityTag model/entity classes\n2. Search for \"tag\" creation patterns in vulnerability services\n3. Look for SmartFix tag application code\n4. Check for any tag constants or configuration\n5. Review workflow code that applies tags\n6. Document findings in the design spec\n\n## Design Document to Update\n\n**IMPORTANT**: All findings must be added to the design specification:\n\n**File**: `plans/mcp-14-vulnerability-filters-design.md`\n\n**Section**: 7. Vulnerability Tags Filter (`vulnTags`)\n\n**What to add**:\n- Update \"Common tag values to document\" subsection (currently lines 401-403)\n- Add complete list of discovered tags with descriptions\n- Add use case examples for each tag\n- Update AI Guidance section with common tag examples\n- Add filter combination examples\n\n**Current placeholder text to replace**:\n```\n- Common tag values to document:\n  - \"SmartFix Remediated\" - Applied by SmartFix when it remediates a vulnerability\n  - Custom tags defined by users for workflow management\n```\n\n**Replace with comprehensive list including**:\n- All system-generated tags (with when/how they're applied)\n- Common workflow tags\n- Tag descriptions and use cases\n- Example queries for each tag type","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-31T11:18:57.097425-04:00","updated_at":"2025-10-31T11:18:57.097425-04:00","closed_at":"2025-10-18T01:31:33.918945-04:00"}
{"id":"mcp-25","content_hash":"883a5d8a85df7772b5162c51ae8b4159e5867e6c39551ba56d34f2c2e85dbb3f","title":"Fix environments and tags fields - empty in vulnerability responses","description":"The environments field in VulnLight responses is coming back empty because SDK's Trace model doesn't include the server_environments field that the teamserver API returns.\n\nTeamserver API returns:\n- server_environments (List\u0026lt;ServerEnvironment\u0026gt;) - lightweight, just environment values\n\nSDK Trace model only has:\n- servers (List\u0026lt;Server\u0026gt;) - full server objects, requires expand=servers\n\nCurrent code tries to extract from trace.getServers() but it's null/empty without expand.","design":"Decision: Add both server_environments and tags fields to SDK Trace model (AIML-194 + sdk-3)\n\nSDK changes required:\n1. Add fields to contrast-sdk-java/sdk/.../models/Trace.java (AIML-194):\n```java\n@SerializedName(\"server_environments\")\nprivate List\u003cString\u003e serverEnvironments;\n\npublic List\u003cString\u003e getServerEnvironments() {\n  return serverEnvironments;\n}\n\n@SerializedName(\"tags\")\nprivate List\u003cString\u003e tags;\n\npublic List\u003cString\u003e getTags() {\n  return tags;\n}\n```\n\n2. Add SERVER_ENVIRONMENTS to TraceExpandValue enum (sdk-3):\n```java\nSERVER_ENVIRONMENTS(\"server_environments\")\n```\n\nMCP changes needed:\n- Update ALL SDK trace calls to include expand=server_environments\n- Update extractEnvironments() to use trace.getServerEnvironments() instead of trace.getServers()\n- Add tags field to VulnLight record\n- Extract tags from trace.getTags()\n\nLocations to add expand parameter:\n- AssessService.listVulnsByAppId() - getTracesExtended() call\n- AssessService.listVulnsInAppByNameForLatestSession() - getTracesExtended() call  \n- AssessService.getAllVulnerabilities() - getTraces()/getTracesInOrg() calls\n- Any other trace retrieval methods\n\nPros: Lightweight, no full server objects, enables both features\nCons: Requires SDK changes (AIML-194 + sdk-3)","acceptance_criteria":"SDK changes (AIML-194 + sdk-3):\n- server_environments field added to SDK Trace model\n- tags field added to SDK Trace model\n- SERVER_ENVIRONMENTS added to TraceExpandValue enum\n\nMCP changes:\n- Add tags field to VulnLight record\n- Pass expand=server_environments to ALL SDK trace calls:\n  * listVulnsByAppId()\n  * listVulnsInAppByNameForLatestSession()\n  * getAllVulnerabilities() (both org and app-level)\n- Update extractEnvironments() to use trace.getServerEnvironments()\n- Extract and populate tags from trace.getTags()\n- Environments populated in all vulnerability responses\n- Tags populated in all vulnerability responses\n- Test with real API to verify data returned\n- No performance issues with large server counts","notes":"SDK changes complete: AIML-194 added fields, sdk-3 added SERVER_ENVIRONMENTS to enum.\n\nMCP implementation details:\n\n1. SDKExtension methods (uses hardcoded expand in URL):\n   - getTracesExtended() line 346: Change \"?expand=session_metadata\" to \"?expand=session_metadata,server_environments\"\n   - getTraces() line 320: Change \"?expand=session_metadata\" to \"?expand=session_metadata,server_environments\"\n\n2. Standard SDK calls (use TraceFilterForm.expand):\n   - getAllVulnerabilities() line 509-521: Add filterForm.setExpand(EnumSet.of(TraceExpandValue.SERVER_ENVIRONMENTS)) before SDK calls\n   \n3. Update extractEnvironments() method (line 667-677):\n   - Change from trace.getServers() to trace.getServerEnvironments()\n   - Remove stream mapping, return directly\n\n4. Add tags to VulnLight:\n   - See mcp-28 (blocked on this)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-10-31T11:18:57.098057-04:00","updated_at":"2025-10-31T11:18:57.098057-04:00","closed_at":"2025-10-30T22:26:31.979227-04:00","external_ref":"https://contrast.atlassian.net/browse/AIML-194"}
{"id":"mcp-26","content_hash":"37603757031f78feddaaacf64514d653163d83ce7d5d655a9dcd0cbdebe0fce6","title":"AIML-193 Fix SDK filterTags URL encoding bug and remove MCP workaround","description":"SDK's TraceFilterForm doesn't URL-encode the filterTags parameter (unlike appVersionTags which IS encoded). This causes 400 errors when tags contain spaces like \"SmartFix Remediated\".\n\nCurrent MCP workaround: Pre-encode tags in VulnerabilityFilterParams before passing to SDK (see VulnerabilityFilterParams.java:209-221)\n\nSDK bug location: contrast-sdk-java/sdk/.../http/TraceFilterForm.java:148-150\n```java\nif (filterTags != null \u0026amp;\u0026amp; !filterTags.isEmpty()) {\n  filters.add(\"filterTags=\" + String.join(\",\", filterTags));  // NO ENCODING!\n}\n```\n\nCompare to appVersionTags (line 169) which correctly uses URLEncoder.encode()","design":"Fix in SDK TraceFilterForm.java:\n```java\nif (filterTags != null \u0026amp;\u0026amp; !filterTags.isEmpty()) {\n  filters.add(\"filterTags=\" + URLEncoder.encode(String.join(\",\", filterTags), \"UTF-8\"));\n}\n```\n\nThen remove workaround from MCP:\n- Remove URL encoding from VulnerabilityFilterParams.java:209-221\n- Remove imports: URLEncoder, UnsupportedEncodingException\n- Update tests to expect unencoded values\n- Update test comment explaining this was a workaround","acceptance_criteria":"- SDK TraceFilterForm encodes filterTags parameter\n- MCP workaround removed from VulnerabilityFilterParams\n- Tests updated (no longer expect encoded values)\n- Tags with spaces work correctly (e.g., \"SmartFix Remediated\")\n- No 400 errors when using vulnTags filter","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-10-31T11:18:57.098876-04:00","updated_at":"2025-10-31T11:18:57.098876-04:00","closed_at":"2025-10-31T00:26:19.653067-04:00","external_ref":"https://contrast.atlassian.net/browse/AIML-193"}
{"id":"mcp-27","content_hash":"f70cb45b34654a1f4baf7179b13d261e5f3dd8f4e3dd97c040829c50674d3891","title":"Generate comprehensive AI-driven test plan for MCP Server","description":"Create a comprehensive test plan that AI can execute to validate all MCP Server functionality using real data from a Contrast instance.\n\nThe test plan should:\n1. Discovery phase - Enumerate available data (apps, vulns, servers, tags, etc.)\n2. Use discovered data to test all tools with realistic scenarios\n3. Validate responses are correct and complete\n4. Cover edge cases (empty results, pagination, filtering, errors)\n\nCurrently we have unit tests but no comprehensive integration test suite that validates the entire MCP Server against real Contrast data.\n\nThis would serve as:\n- Validation tool for new releases\n- Regression test suite\n- Documentation of expected behavior\n- Smoke test for customer environments","design":"Test Plan Structure:\n\nPhase 1: Discovery\n- list_applications - Get all apps, pick test app with vulns\n- list_vulnerability_types - Get available vuln types\n- Check for vulnerabilities across org\n- Identify apps with different statuses/severities\n- Find apps with ADR data if available\n\nPhase 2: Core Functionality Tests\nFor each tool, test with discovered data:\n\nAssessService:\n- get_vulnerability_details (using real vuln IDs)\n- list_vulnerabilities_by_app (using test app)\n- list_vulnerabilities_by_app_name (using app names)\n- list_all_vulnerabilities (all filter combinations)\n  * Pagination (page 1, 2, beyond limit)\n  * Severity filters (single, multiple, invalid)\n  * Status filters (Reported, Confirmed, Fixed, etc.)\n  * Environment filters (PRODUCTION, QA, DEVELOPMENT)\n  * Date filters (lastSeenAfter, lastSeenBefore, ranges)\n  * vulnTypes (single, multiple, from discovered types)\n  * vulnTags (with spaces like \"SmartFix Remediated\")\n  * appId filtering\n  * Combined filters (severity + env + dates)\n- list_vulnerability_types (verify complete list)\n\nADRService (if applicable):\n- get_attacks (basic retrieval)\n- get_attacks_filtered (with various filters)\n- get_protect_rules (if ADR enabled)\n\nSCAService:\n- get_libraries_by_app (using test app)\n\nPhase 3: Edge Cases\n- Empty result scenarios\n- Invalid parameters (bad dates, invalid enums)\n- Pagination beyond available pages\n- Very large result sets\n- Special characters in filters\n\nPhase 4: Response Validation\nFor each response, verify:\n- Required fields present (environments, dates, status, etc.)\n- Data types correct\n- Pagination metadata accurate (totalItems, hasMorePages)\n- Environments field populated correctly\n- Date fields in correct format\n- Validation messages helpful for bad input\n\nDeliverable:\n- MANUAL_TEST_PLAN.md with step-by-step instructions\n- Checklist format for manual execution\n- Later: Automated test suite that AI can run","acceptance_criteria":"- Test plan document created covering all MCP tools\n- Discovery phase identifies real data to use\n- Each tool has multiple test scenarios\n- Edge cases documented\n- Expected results specified\n- Can be executed manually with checklist\n- Validates key functionality: pagination, filtering, environments field, vulnTags with spaces\n- Covers happy path and error scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.099736-04:00","updated_at":"2025-10-31T11:18:57.099736-04:00"}
{"id":"mcp-28","content_hash":"bb6f8206c38fcbceec0c2b86c9172cab34e896bf69f139a773c5550dd31a0c80","title":"Add tags field to VulnLight responses","description":"Add vulnerability tags to VulnLight record and populate from SDK Trace model once AIML-194 adds tags field to SDK.\n\nCurrent state:\n- VulnLight.java has NO tags field\n- SDK Trace model has NO tags field (AIML-194 will add it)\n- TeamServer returns tags in vulnerability responses\n\nChanges needed:\n1. Add tags field to VulnLight record (VulnLight.java:22-35)\n2. Extract tags from trace.getTags() in AssessService\n3. Populate tags in all places VulnLight is created:\n   - listVulnsByAppId() (line 180-183)\n   - listVulnsInAppByNameForLatestSession() (line 257-260)\n   - getAllVulnerabilities() (line 530-542)\n\nImplementation:\n```java\n// VulnLight.java\npublic record VulnLight(\n    String title,\n    String type,\n    String vulnID,\n    String severity,\n    List\u003cSessionMetadata\u003e sessionMetadata,\n    String lastSeenDate,\n    long lastSeenTime,\n    String status,\n    Long firstTimeSeen,\n    Long closedTime,\n    List\u003cString\u003e environments,\n    List\u003cString\u003e tags  // ADD THIS\n) {}\n\n// AssessService.java - in each VulnLight creation\nnew VulnLight(\n    trace.getTitle(),\n    trace.getRule(),\n    trace.getUuid(),\n    trace.getSeverity(),\n    trace.getSessionMetadata(),\n    new Date(trace.getLastTimeSeen()).toString(),\n    trace.getLastTimeSeen(),\n    trace.getStatus(),\n    trace.getFirstTimeSeen(),\n    trace.getClosedTime(),\n    traceEnvironments,\n    trace.getTags()  // ADD THIS\n)\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.100625-04:00","updated_at":"2025-10-31T11:18:57.100625-04:00","closed_at":"2025-10-30T21:12:39.50675-04:00","external_ref":"https://contrast.atlassian.net/browse/AIML-194","dependencies":[{"issue_id":"mcp-28","depends_on_id":"mcp-25","type":"blocks","created_at":"2025-10-31T11:18:57.138261-04:00","created_by":"auto-import"}]}
{"id":"mcp-29","content_hash":"7dc4771f0d3b42681c1db90facfb3796706586de76a2d2e8b9c7089a753298f8","title":"Add test coverage for listVulnerabilityTypes method","description":"The listVulnerabilityTypes() method in AssessService lacks test coverage.\n\nMethod location: AssessService.java (around line 692)\n\nThe method:\n- Calls contrastSDK.getRules(orgID)\n- Extracts rule names from the response\n- Filters null/empty names\n- Sorts alphabetically\n- Returns list of vulnerability type strings\n\nTests needed:\n1. Happy path: Returns sorted list of rule names\n2. Empty response: Handle null or empty Rules response\n3. Null names: Filter out null/empty rule names correctly\n4. Sorting: Verify alphabetical order\n5. Error handling: SDK throws exception\n\nSimilar to existing AssessServiceTest patterns using mocked SDK responses.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.101335-04:00","updated_at":"2025-10-31T11:18:57.101335-04:00","closed_at":"2025-10-19T21:52:50.122466-04:00"}
{"id":"mcp-3","content_hash":"74b9fdd1e254c4eb0016cc6474b11ea961cfb0fc94a6d9c669b541da0562e510","title":"Consolidate ADR service methods","description":"Consolidate getAttacks and getAttacksFiltered methods in ADRService.java:172 into one method. Don't need two separate tools - one method should handle both cases (with optional filters).\n\nFlagged by: ChrisEdwards in PR #21","status":"closed","priority":1,"issue_type":"chore","created_at":"2025-10-31T11:18:57.101967-04:00","updated_at":"2025-10-31T11:18:57.101967-04:00","closed_at":"2025-10-20T23:52:16.960353-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21","dependencies":[{"issue_id":"mcp-3","depends_on_id":"mcp-13","type":"blocks","created_at":"2025-10-31T11:18:57.139287-04:00","created_by":"auto-import"}]}
{"id":"mcp-30","content_hash":"ab3f1310d79cd07f8ffbffaa8354c71fd751a3501b45827ff2c2e9314fd6d589","title":"REFACTORING: Extract BaseContrastService","description":"Extract base service class to eliminate SDK initialization duplication (19x occurrences). High impact, low risk foundation work.","design":"See plans/opus-cleanup-refactoring-plan.md section \"1. Extract Base Service Class\"","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-31T11:18:57.104039-04:00","updated_at":"2025-10-31T11:18:57.104039-04:00"}
{"id":"mcp-31","content_hash":"ba3195f918b80ee2d008b7667ac6247708bda2c52c3caefa9a8e48728379442f","title":"REFACTORING: Create VulnerabilityMapper","description":"Centralize all vulnerability transformation logic to eliminate duplication across 5+ places. High impact, low risk.","design":"See plans/opus-cleanup-refactoring-plan.md section \"2. Create Vulnerability Mapper\"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-31T11:18:57.104582-04:00","updated_at":"2025-10-31T11:18:57.104582-04:00","closed_at":"2025-10-20T13:56:02.944566-04:00"}
{"id":"mcp-32","content_hash":"e7f723d521375578730e5a4678957967263ba52084b9404d4e670708cb942887","title":"REFACTORING: Extract PaginationHandler","description":"Create reusable pagination handler component. Can be reused across all services. High impact, low risk.","design":"See plans/opus-cleanup-refactoring-plan.md section \"3. Extract Pagination Handler\"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-31T11:18:57.105159-04:00","updated_at":"2025-10-31T11:18:57.105159-04:00","closed_at":"2025-10-20T15:16:37.124389-04:00"}
{"id":"mcp-33","content_hash":"72f1abef77a617fe69ee7518a7181f29e1228e1fe16e21e4c807465eec33342f","title":"REFACTORING: Create VulnerabilityFilterValidator","description":"Extract filter validation logic into dedicated component with clear error messages. High impact, medium risk.","design":"See plans/opus-cleanup-refactoring-plan.md section \"6. Create Filter Validator\"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.105928-04:00","updated_at":"2025-10-31T11:18:57.105928-04:00","closed_at":"2025-10-20T21:01:54.522408-04:00"}
{"id":"mcp-34","content_hash":"186c5480622f06cad5d34af3189aea11ca5db36b45df244cc7e1a8960ec4d682","title":"REFACTORING: Break down getAllVulnerabilities method","description":"Split 180-line getAllVulnerabilities into focused sub-methods (validate, fetch, paginate). Biggest maintenance win. High impact, medium risk.","design":"See plans/opus-cleanup-refactoring-plan.md section \"4. Break Down getAllVulnerabilities Method\"","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.106776-04:00","updated_at":"2025-10-31T11:18:57.106776-04:00","dependencies":[{"issue_id":"mcp-34","depends_on_id":"mcp-30","type":"blocks","created_at":"2025-10-31T11:18:57.140193-04:00","created_by":"auto-import"},{"issue_id":"mcp-34","depends_on_id":"mcp-31","type":"blocks","created_at":"2025-10-31T11:18:57.141118-04:00","created_by":"auto-import"},{"issue_id":"mcp-34","depends_on_id":"mcp-32","type":"blocks","created_at":"2025-10-31T11:18:57.142263-04:00","created_by":"auto-import"},{"issue_id":"mcp-34","depends_on_id":"mcp-33","type":"blocks","created_at":"2025-10-31T11:18:57.14319-04:00","created_by":"auto-import"}]}
{"id":"mcp-35","content_hash":"df4cb4a0fe91b30a5071954175e44d558ffa85ccfc2aeff4b744e9f9431c9e8a","title":"REFACTORING: Extract StackAnalyzer service","description":"Create dedicated service for complex library matching and stack trace analysis. High impact, medium risk.","design":"See plans/opus-cleanup-refactoring-plan.md section \"5. Extract Stack Analyzer Service\"","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.10769-04:00","updated_at":"2025-10-31T11:18:57.10769-04:00","dependencies":[{"issue_id":"mcp-35","depends_on_id":"mcp-30","type":"blocks","created_at":"2025-10-31T11:18:57.145484-04:00","created_by":"auto-import"}]}
{"id":"mcp-36","content_hash":"b4ab2d25b7be80ee943907280970eedfc8fdc5dc9a1fe26735a34929d280e378","title":"REFACTORING: Simplify getVulnerabilityById method","description":"Refactor 66-line getVulnerabilityById into focused components using extracted services. Medium impact, low risk.","design":"See plans/opus-cleanup-refactoring-plan.md section \"7. Simplify getVulnerabilityById\"","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-31T11:18:57.108343-04:00","updated_at":"2025-10-31T11:18:57.108343-04:00","dependencies":[{"issue_id":"mcp-36","depends_on_id":"mcp-30","type":"blocks","created_at":"2025-10-31T11:18:57.146254-04:00","created_by":"auto-import"},{"issue_id":"mcp-36","depends_on_id":"mcp-31","type":"blocks","created_at":"2025-10-31T11:18:57.147311-04:00","created_by":"auto-import"},{"issue_id":"mcp-36","depends_on_id":"mcp-35","type":"blocks","created_at":"2025-10-31T11:18:57.14819-04:00","created_by":"auto-import"}]}
{"id":"mcp-37","content_hash":"4fdee48ccc36ae4c759ebaf568a55811f7f04fe1e901742f61aa32f4617eebce","title":"REFACTORING: Simplify session metadata filtering","description":"Replace deeply nested loops (5 levels) with clean stream-based filtering. Medium impact, low risk.","design":"See plans/opus-cleanup-refactoring-plan.md section \"8. Simplify Session Metadata Filtering\"","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-31T11:18:57.108914-04:00","updated_at":"2025-10-31T11:18:57.108914-04:00","dependencies":[{"issue_id":"mcp-37","depends_on_id":"mcp-30","type":"blocks","created_at":"2025-10-31T11:18:57.149173-04:00","created_by":"auto-import"}]}
{"id":"mcp-38","content_hash":"c2dde1f48708d0855c4397b4c5aff27f3daece17dbb8572a1440a84952dcc7ed","title":"Fix unbounded memory usage in getAllVulnerabilities fallback","description":"The fallback approach in getAllVulnerabilities fetches ALL vulnerabilities from ALL applications into memory when the org-level API fails. This could cause OutOfMemoryError with large datasets.\n\n## Problem\n\nIn AssessService.getAllVulnerabilities() around line 540-560, when the org-level API returns null/fails, the code falls back to:\n```java\nfor (Application app : applications) {\n    List\u003cVulnLight\u003e appVulns = listVulnsByAppId(app.getAppId());\n    allVulnerabilities.addAll(appVulns); // Unbounded memory growth!\n}\n```\n\nThis loads all vulnerabilities from all applications into memory at once, which could be millions of records in large organizations.\n\n## Potential Solutions\n\n1. **Add pagination to fallback**: Process apps in batches, paginate within each app\n2. **Streaming approach**: Process and return results incrementally\n3. **Add memory limit**: Track approximate memory usage and fail gracefully\n4. **Limit fallback scope**: Only use fallback for specific app, not org-wide queries\n5. **Remove fallback**: Fail fast if org API doesn't work, document requirements\n\n## Impact\n\n- Risk of OutOfMemoryError in production\n- Poor performance with large datasets\n- Unpredictable memory usage\n\n## Related\n\n- PR #21 code review identified this issue\n- getAllVulnerabilities method (AssessService.java:540-560)","notes":"## Root Cause Analysis - COMPLETED\n\n### When the Fallback Was Added\n**Commit**: 143273099ee9c274bc90912e32a98e3c8561a0a2  \n**Author**: Aurelien SVEVI  \n**Date**: Oct 14, 2025  \n**Message**: \"add vulns creation/closeTime + create getAllVuln endpoint\"\n\n### Original Fallback Logic (Line 530)\n```java\nif (traces != null \u0026\u0026 traces.getTraces() != null \u0026\u0026 !traces.getTraces().isEmpty()) {\n    // Organization API worked, use it\n} else {\n    // Fallback to application-by-application approach\n    logger.warn(\"Organization-level API returned no results, using fallback approach\");\n```\n\n### The Bug: Misunderstanding of Empty Results\nThe original developer treated **empty results as an API failure**, but this is wrong!\n\n**Fallback triggers in 3 cases**:\n1. `traces == null` - Gson parsing returned null (malformed JSON? - RARE)\n2. `traces.getTraces() == null` - Missing `traces` field in response (RARE) \n3. `traces.getTraces().isEmpty()` - **Zero vulnerabilities (VALID RESPONSE!)** ‚Üê THE BUG\n\n**Case #3 is NOT an error** - it just means the org has no vulnerabilities!\n\n### SDK Behavior - Does NOT Return Null for Permissions\n\n**SDK Code** (ContrastSDK.java:1262-1271):\n```java\npublic Traces getTracesInOrg(String organizationId, TraceFilterForm form)\n    throws IOException, UnauthorizedException {\n  try (InputStream is = makeRequest(HttpMethod.GET, ...)) {\n    return this.gson.fromJson(reader, Traces.class);\n  }\n}\n```\n\n**When HTTP status \u003e= 400 (including 403 Forbidden)**:\n- `makeRequest()` **throws HttpResponseException** (lines 1530-1533)\n- Does NOT return null\n\n**TeamServer Response** (NgOrganizationTraceListingRestController.java:437-441):\n```java\nif (eacUser.hasNoApplicationsAllowed() || ...) {\n  response.setCount(0L);\n  response.setTraces(Collections.emptyList());\n  return ResponseEntity.ok(response);  // HTTP 200 with empty list!\n}\n```\n\n**When user lacks EAC access**: TeamServer returns HTTP 200 with `count=0`, `traces=[]` (not null!)\n\n**Conclusion**: The fallback is **likely dead code** that only triggers when there are legitimately zero vulnerabilities.\n\n### EAC Permissions Verification - IDENTICAL IN BOTH PATHS\n\n**Question**: Does the fallback provide access to apps that org-level API doesn't?  \n**Answer**: NO - Both paths respect EAC identically.\n\n#### Org-Level API Path\n**Endpoint**: `/ng/{orgUuid}/orgtraces/filter`  \n**Code**: NgOrganizationTraceListingRestController.java:434-442\n\n```java\nfinal EacUser eacUser =\n    eacAccessControlService.getAccessControlForUser(org.getId(), AuthHelper.getUsername());\n\nif (eacUser.hasNoApplicationsAllowed() ...) {\n  response.setCount(0L);\n  response.setTraces(Collections.emptyList());\n  return ResponseEntity.ok(response);\n}\n```\n\n- Returns vulnerabilities **only from apps user can access**\n- If user has 0 apps allowed: returns empty list with count=0\n- If user has some apps: returns vulns from those apps only\n\n#### Fallback Path\n**MCP Code**: SDKHelper.getApplicationsWithCache() ‚Üí calls `/ng/{orgUuid}/applications`  \n**TeamServer**: NgApplicationsRestController.java:746-755\n\n```java\nfinal List\u003cApplication\u003e apps =\n    applicationService.findAppsByOrganizationAndTags(\n        org,\n        username,  // ‚Üê EAC filtering happens here\n        ...\n    );\n```\n\n- Returns **only apps user has EAC access to**\n- Then for each app: calls `/ng/{orgUuid}/traces/{appId}/filter`\n- Each app-specific call has `@PreAuthorize(\"hasApplicationAccess(#org,#app)\")` (line 106)\n- Would throw 403 if user lacks access to that app\n\n**Conclusion**: Fallback provides **zero additional access** - it's just an inefficient way to get the same EAC-filtered data.\n\n## Recommended Solution: Remove Fallback Entirely\n\n### Why Remove It?\n1. **Triggers incorrectly**: Treats empty results (zero vulns) as an error\n2. **No permission benefit**: Both paths filter by identical EAC rules  \n3. **Causes OutOfMemoryError**: Loads ALL vulns from ALL (accessible) apps into memory\n4. **Broken logic**: If org API fails due to real errors, masking them is unhelpful\n5. **Dead code**: Likely never triggers except when there are zero vulnerabilities\n\n### Implementation\nReplace lines 553-583 with clear error handling:\n```java\n} else {\n    // Org-level API returned null - unexpected condition\n    String errorMsg = String.format(\n        \"Org-level vulnerability API returned null for org %s. \" +\n        \"This is unexpected - the API should return an empty list if no vulnerabilities exist. \" +\n        \"Please check API connectivity and permissions.\",\n        orgID\n    );\n    logger.error(errorMsg);\n    return PaginatedResponse.error(pagination.page(), pagination.pageSize(), errorMsg);\n}\n```\n\n**Why this works**:\n- TeamServer returns HTTP 200 with empty list for zero vulns (handled at line 530)\n- TeamServer returns HTTP 200 with empty list for no EAC access (handled at line 530)\n- HTTP errors (403, 500, etc.) throw exceptions in SDK (not caught here)\n- NULL should never happen in practice - if it does, it's a real error worth reporting\n\n### Alternative Considered: Fix the Check\n```java\nif (traces != null \u0026\u0026 traces.getTraces() != null) {\n    // Use org API results (even if empty)\n} else {\n    // Only fallback if truly null\n}\n```\n\nBut this still doesn't solve the memory problem - the fallback is fundamentally broken. Better to remove it.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-31T11:18:57.109812-04:00","updated_at":"2025-10-31T11:18:57.109812-04:00","closed_at":"2025-10-31T00:17:10.658981-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-39","content_hash":"454bc7e304f5ad8e6761d67b44f29c7c402954938c1708af92efbd42273b7582","title":"Document SDK filterTags workaround with JIRA reference","description":"The code uses URL encoding for filterTags as a workaround for an SDK bug, but the workaround lacks a JIRA/GitHub issue reference explaining why it's needed.\n\n## Current State\n\nIn VulnerabilityFilterParams.java around line 318, there's a workaround:\n```java\n// URL encode tags to work around SDK bug with spaces\nform.getFilterTags().add(URLEncoder.encode(tag, \"UTF-8\"));\n```\n\n## Issue\n\n- The workaround exists but lacks documentation linking to the SDK bug\n- AIML-193 tracks fixing this in the SDK (per mcp-26)\n- Future developers won't know why this encoding is necessary\n- When SDK is fixed, we won't know to remove the workaround\n\n## Action Needed\n\nAdd a comment with JIRA reference:\n```java\n// WORKAROUND for SDK bug (AIML-193): TraceFilterForm doesn't URL-encode \n// filterTags parameter, causing 400 errors with spaces like \"SmartFix Remediated\"\n// Remove this encoding when SDK is fixed\nform.getFilterTags().add(URLEncoder.encode(tag, \"UTF-8\"));\n```\n\n## Related\n\n- mcp-26: Tracks fixing the SDK bug itself\n- AIML-193: JIRA ticket for SDK fix\n- PR #21 code review identified missing documentation","notes":"AIML-193 is complete - SDK now properly encodes filterTags. Need to remove the workaround code and related tests.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.110983-04:00","updated_at":"2025-10-31T11:18:57.110983-04:00","closed_at":"2025-10-30T23:07:58.259828-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-4","content_hash":"a50fa97dd116bf4b463652bca535923c975a9e195e8ad60b0451e79ee6409218","title":"Add keyword filtering to ADR getAttacksFiltered description","description":"Include \"keyword\" in the list of filtering possibilities in ADRService.java:171 tool description so that the LLM knows it can supply a keyword as well.\n\nFlagged by: JacobMagesHaskinsContrast in PR #21","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.111896-04:00","updated_at":"2025-10-31T11:18:57.111896-04:00","closed_at":"2025-10-20T23:52:18.25188-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21","dependencies":[{"issue_id":"mcp-4","depends_on_id":"mcp-13","type":"blocks","created_at":"2025-10-31T11:18:57.150225-04:00","created_by":"auto-import"}]}
{"id":"mcp-40","content_hash":"b047c3a3a60cba6e9ffc7c4819b14d459ebda3ea5f610093f7906b6cf4fc837c","title":"Refactor AttacksFilterBody to use Builder pattern","description":"AttacksFilterBody has 13 mutable fields with complex initialization, making it error-prone and hard to use correctly.\n\n## Current Issues\n\nAttacksFilterBody.java has:\n- 13 mutable fields with getters/setters\n- Complex constructor that initializes 9 ArrayLists\n- All fields are mutable after construction\n- Easy to forget initialization or set wrong combinations\n\n## Problems This Causes\n\n1. **Mutability issues**: Can be modified after passing to methods\n2. **Initialization complexity**: Easy to forget to initialize lists\n3. **No validation**: Can set invalid combinations\n4. **Verbose usage**: Requires many setter calls\n\n## Recommended Solution: Builder Pattern\n\n```java\npublic class AttacksFilterBody {\n    private final String quickFilter;\n    private final List\u003cString\u003e tags;\n    // ... other fields as final\n    \n    private AttacksFilterBody(Builder builder) {\n        this.quickFilter = builder.quickFilter;\n        this.tags = List.copyOf(builder.tags);\n        // ...\n    }\n    \n    public static class Builder {\n        private String quickFilter = \"\";\n        private List\u003cString\u003e tags = new ArrayList\u003c\u003e();\n        \n        public Builder quickFilter(String val) {\n            this.quickFilter = val;\n            return this;\n        }\n        \n        public AttacksFilterBody build() {\n            return new AttacksFilterBody(this);\n        }\n    }\n}\n```\n\n## Benefits\n\n- Immutable after construction\n- Fluent API for building\n- Optional validation in build()\n- Clear intent in usage\n\n## Related\n\n- PR #21 code review identified this complexity\n- ADRService uses this class","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.112605-04:00","updated_at":"2025-10-31T11:18:57.112605-04:00","closed_at":"2025-10-21T00:07:18.350502-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-41","content_hash":"4e55c7d0b703dfb5dc025c1bfcb1c2aa0d0d0330d6240b87d5cd25688ba3c7ff","title":"Replace hardcoded timestamps in tests with relative calculations","description":"Tests use hardcoded epoch timestamps (e.g., 1705328400000L) which are hard to understand and maintain.\n\n## Current Issues\n\nThroughout test files, especially AssessServiceTest.java, we see:\n```java\nwhen(trace.getLastTimeSeen()).thenReturn(1705328400000L); // What date is this?\nwhen(trace.getFirstTimeSeen()).thenReturn(1705242000000L); // ???\n```\n\n## Problems\n\n1. **Unreadable**: Can't tell what date 1705328400000L represents\n2. **Unmaintainable**: Hard to adjust for testing different scenarios\n3. **Brittle**: Tests might break when dates become too old\n4. **No context**: Doesn't show relationship between dates\n\n## Recommended Solution\n\nUse relative time calculations:\n```java\n// Clear and maintainable\nInstant now = Instant.now();\nInstant yesterday = now.minus(1, ChronoUnit.DAYS);\nInstant lastWeek = now.minus(7, ChronoUnit.DAYS);\n\nwhen(trace.getLastTimeSeen()).thenReturn(now.toEpochMilli());\nwhen(trace.getFirstTimeSeen()).thenReturn(lastWeek.toEpochMilli());\n```\n\nOr use constants with clear names:\n```java\nprivate static final long JAN_15_2025_10_30_UTC = \n    LocalDateTime.of(2025, 1, 15, 10, 30)\n        .toInstant(ZoneOffset.UTC)\n        .toEpochMilli();\n```\n\n## Files Affected\n\n- AssessServiceTest.java\n- VulnerabilityMapperTest.java\n- Any other test files using epoch timestamps\n\n## Benefits\n\n- Self-documenting test data\n- Easy to understand time relationships\n- Maintainable test scenarios\n- Won't break as time passes\n\n## Related\n\n- PR #21 code review identified this issue","status":"closed","priority":3,"issue_type":"task","assignee":"chris","created_at":"2025-10-31T11:18:57.113238-04:00","updated_at":"2025-10-31T11:18:57.113238-04:00","closed_at":"2025-10-20T19:30:01.960425-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-42","content_hash":"71eab283a15fdfb58f21b4c3ac78ac856e5c9807deff8fffeba0f3b2128c13b0","title":"Standardize error handling between ADRService and AssessService","description":"ADRService and AssessService handle similar error conditions differently, creating inconsistent behavior.\n\n## Inconsistency Found\n\nIn ADRService.java (getAttacks method):\n```java\nif (attacks == null || attacks.isEmpty()) {\n    logger.warn(\"No attacks data returned\");\n    return List.of(); // Returns empty list\n}\n```\n\nIn AssessService.java (similar scenarios):\n```java\n// Some methods throw IOException for empty/null results\nthrow new IOException(\"Failed to retrieve data\");\n```\n\n## Problems\n\n1. **Inconsistent API behavior**: Same condition, different responses\n2. **Confusing for AI agents**: Can't predict error vs empty list\n3. **Debugging difficulty**: Errors hidden as empty results\n4. **No clear contract**: When should we throw vs return empty?\n\n## Recommended Approach\n\nEstablish clear patterns:\n- **Null from SDK** = Throw IOException (API failure)\n- **Empty list from SDK** = Return empty list (no data)\n- **Partial failure** = Log warning, return what we have\n- **Complete failure** = Throw with descriptive message\n\n## Standardization Needed\n\n1. Review all service methods for consistency\n2. Document error handling strategy\n3. Apply consistent patterns:\n   ```java\n   if (result == null) {\n       throw new IOException(\"API returned null - possible connection issue\");\n   }\n   if (result.isEmpty()) {\n       logger.debug(\"No data found for query\");\n       return List.of();\n   }\n   ```\n\n## Files to Review\n\n- ADRService.java (all methods)\n- AssessService.java (all methods)\n- Other service classes\n\n## Related\n\n- PR #21 code review identified this inconsistency","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.114291-04:00","updated_at":"2025-10-31T11:18:57.114291-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-43","content_hash":"431a79fa78953033c299b08e771966a2ab9d589d6a584e3e532b9f037e7fc814","title":"Add null checks for getFilterTags() in tests","description":"Tests directly access getFilterTags() result without null checking, could cause NPE if not initialized.\n\n## Issue Found\n\nIn AssessServiceTest.java around line 446:\n```java\nform.getFilterTags().contains(\"SmartFix%20Remediated\")\n// getFilterTags() might return null if not initialized\n```\n\n## Problem\n\n- TraceFilterForm might return null for uninitialized collections\n- Direct method chaining without null check\n- Test could fail with NPE instead of meaningful assertion failure\n\n## Recommended Fix\n\nAdd null checks or use safe navigation:\n```java\nassertNotNull(form.getFilterTags(), \"Filter tags should be initialized\");\nassertTrue(form.getFilterTags().contains(\"SmartFix%20Remediated\"));\n```\n\nOr defensive approach:\n```java\nList\u003cString\u003e tags = form.getFilterTags();\nassertNotNull(tags, \"Expected filter tags to be set\");\nassertTrue(tags.contains(\"SmartFix%20Remediated\"));\n```\n\n## Pattern to Apply\n\nThroughout test files:\n1. Check collection getters aren't null before accessing\n2. Use explicit assertions for null checks\n3. Provide meaningful assertion messages\n\n## Files Affected\n\n- AssessServiceTest.java\n- Other test files that verify filter/parameter objects\n\n## Benefits\n\n- Clear test failures (not NPE)\n- Better debugging when tests fail\n- Explicit verification of expected state\n\n## Related\n\n- PR #21 code review identified this potential NPE","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-10-31T11:18:57.114967-04:00","updated_at":"2025-10-31T11:18:57.114967-04:00","closed_at":"2025-10-31T00:45:53.149436-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-44","content_hash":"a073523cf63bee4364a95779723f521855eab25584f903d05357f4722b083fb1","title":"Add pagination support to get_attacks with accurate totalItems count","description":"Implement full pagination spec compliance for the get_attacks ADR tool. The pagination infrastructure (PaginationParams, PaginationHandler) has been added, but the API response count is being discarded. Need to capture count from API response and expose pagination warnings to AI.","design":"1. Create AttacksResponse wrapper class to capture API metadata (attacks array + count)\n2. Update SDKExtension.getAttacks() to return AttacksResponse instead of List\u003cAttack\u003e\n3. Update ADRService.getAttacks() to:\n   - Use count from API response for totalItems\n   - Pass pagination warnings to PaginationHandler (currently logged only)\n4. Add/update tests for:\n   - AttacksResponse parsing\n   - ADRService.getAttacks() pagination with count\n   - Pagination warnings in response message\n5. Verify spec compliance matches list_all_vulnerabilities pattern","acceptance_criteria":"- AttacksResponse class created with attacks list and count field\n- SDKExtension.getAttacks() returns AttacksResponse with parsed count\n- ADRService.getAttacks() provides accurate totalItems when available\n- Pagination warnings appear in response.message field for AI visibility\n- hasMorePages calculation uses accurate count (not just heuristic)\n- All tests pass including new pagination tests\n- Code matches pagination spec v1.0 standards","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-31T11:18:57.115604-04:00","updated_at":"2025-10-31T11:18:57.115604-04:00","closed_at":"2025-10-21T09:28:20.739582-04:00"}
{"id":"mcp-45","content_hash":"a3c509ad096c2d24993d37a9a3613b9095c936cd1ae10992869d99a9fd1b6daf","title":"Create AttackFilterParams with validation, smart defaults, and warnings propagation","description":"The get_attacks method lacks input validation and doesn't propagate warnings to AI like list_all_vulnerabilities does. Need to create AttackFilterParams class following the same pattern as VulnerabilityFilterParams.\n\n## Current State\n\nget_attacks accepts raw filter parameters and passes them directly to AttacksFilterBody.Builder without validation:\n- No enum validation for quickFilter values\n- No descriptive error messages for invalid input\n- No warnings passed to paginationHandler (ADRService.java:222)\n- AI gets generic exceptions instead of self-correcting feedback\n\n## Required Work\n\n1. **Create AttackFilterParams class** (similar to VulnerabilityFilterParams.java)\n   - Parse and validate quickFilter against valid values\n   - Implement hard vs soft failure distinction\n   - Return descriptive error messages enabling AI self-correction\n   - Support smart defaults (TBD - need to discuss)\n\n2. **Define smart defaults**\n   - What should default quickFilter be? (e.g., active attacks only?)\n   - Should includeSuppressed default to false?\n   - Document rationale for defaults\n\n3. **Update get_attacks method** (ADRService.java:164-244)\n   - Use AttackFilterParams.of() to parse/validate inputs\n   - Check isValid() and return error response if invalid\n   - Pass warnings to paginationHandler.wrapApiPaginatedItems()\n\n4. **Validation strategy**\n   - Hard failures: Invalid quickFilter enum values, invalid sort formats\n   - Soft failures: Out-of-range pagination (already handled by PaginationParams)\n   - Warning messages: Smart defaults applied, filter interpretations\n\n## Design Questions to Answer\n\n- What are valid quickFilter values? (need to check API docs/code)\n- Should we have smart defaults for attacks? (e.g., exclude suppressed by default?)\n- What sort formats are valid?\n- Should keyword be validated or pass-through?\n\n## Integration\n\nUpdate PaginationHandler.wrapApiPaginatedItems() signature if needed to accept warnings parameter consistently.","design":"Pattern: Follow VulnerabilityFilterParams.java structure exactly\n\n1. Record structure:\n```java\npublic record AttackFilterParams(\n    AttacksFilterBody filterBody,\n    List\u0026lt;String\u0026gt; warnings,\n    List\u0026lt;String\u0026gt; errors\n)\n```\n\n2. Static factory method:\n```java\npublic static AttackFilterParams of(\n    String quickFilter,\n    String keyword,\n    Boolean includeSuppressed,\n    Boolean includeBotBlockers,\n    Boolean includeIpBlacklist,\n    String sort\n)\n```\n\n3. Validation approach:\n- Hard failures: Invalid enum values, malformed sort\n- Soft failures: None expected (booleans can't be invalid)\n- Warnings: Smart defaults applied\n\n4. Smart defaults (proposed):\n- No quickFilter default (show all attack types)\n- includeSuppressed = false (only show active attacks)\n- Warning when using defaults: \"Showing active attacks only (excluding suppressed). To see all attacks, set includeSuppressed=true\"\n\n5. Error message examples:\n- \"Invalid quickFilter 'INVALID'. Valid: EXPLOITED, PROBED, BLOCKED, INEFFECTIVE. Example: 'EXPLOITED'\"\n- \"Invalid sort format '-invalid'. Must be field name with optional '-' prefix for descending.\"\n\n6. Update ADRService.getAttacks():\n```java\nAttackFilterParams filters = AttackFilterParams.of(\n    quickFilter, keyword, includeSuppressed, \n    includeBotBlockers, includeIpBlacklist, sort\n);\n\nif (!filters.isValid()) {\n    return PaginatedResponse.error(pagination.page(), pagination.pageSize(), \n        String.join(\" \", filters.errors()));\n}\n\n// Use filters.filterBody() to get AttacksFilterBody\n// Pass filters.warnings() to paginationHandler\n```","acceptance_criteria":"- AttackFilterParams class created following VulnerabilityFilterParams pattern\n- Validates quickFilter against valid enum values (document what they are)\n- Distinguishes hard failures (errors) vs soft failures (warnings)\n- Smart defaults defined and documented with rationale\n- Warning messages are descriptive and enable AI self-correction\n- get_attacks updated to use AttackFilterParams.of()\n- Invalid inputs return PaginatedResponse.error() with descriptive message\n- Warnings passed to paginationHandler.wrapApiPaginatedItems()\n- Tests added verifying validation and error messages\n- Pattern consistent with list_all_vulnerabilities approach","notes":"IMPORTANT: Use \"messages\" not \"warnings\" terminology (per mcp-48 discussion).\n\nAttackFilterParams should follow same pattern as updated VulnerabilityFilterParams:\n- errors: Hard validation failures that throw ToolExecutionException\n- messages: Informational context for AI (not warnings/failures)\n\nThe \"messages\" field contains conversational context like:\n- \"Excluding suppressed attacks by default\"\n- \"Sort adjusted to valid format\"\n- \"No quickFilter applied - showing all attack types\"\n\nThese aren't errors or warnings - they help AI understand what happened without being failures.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-31T11:18:57.116264-04:00","updated_at":"2025-10-31T11:18:57.116264-04:00","closed_at":"2025-10-30T22:55:07.340129-04:00"}
{"id":"mcp-46","content_hash":"84d77f4729df4e74f30506c6d334a67c2c498cac4336d8ff64a65ce295c7413f","title":"Standardize empty result handling in get_attacks to match list_all_vulnerabilities","description":"get_attacks and list_all_vulnerabilities handle empty results inconsistently. When no data is returned, the user experience differs between the two methods.\n\n## Current Inconsistency\n\n**list_all_vulnerabilities** (AssessService.java:529-550):\n- Returns paginated response with items\n- PaginationHandler adds appropriate message field\n- Distinguishes between \"no results\" and \"API failure\"\n- Communicates empty state to AI via response message\n\n**get_attacks** (ADRService.java:207-226):\n- Returns empty list without special handling\n- Logs \"No attacks data returned\" at debug level\n- No message field in response explaining empty result\n- AI receives empty list with no context\n\n## Issue\n\nAI agents benefit from explicit messaging about why results are empty:\n- \"No attacks found matching your filters\"\n- \"No ADR data available for this organization\"\n- Empty vs no-access vs filtered-out scenarios\n\n## Desired State\n\nget_attacks should communicate empty results the same way list_all_vulnerabilities does, using PaginationHandler's message field to provide context.\n\n## Implementation\n\nDetermine what PaginationHandler does with empty results and ensure get_attacks follows the same pattern. May need to pass additional context to distinguish between:\n1. API returned empty list (no attacks exist)\n2. Filters excluded all attacks\n3. No ADR enabled for organization","design":"Review how PaginationHandler.wrapApiPaginatedItems() handles empty results:\n- Check if it automatically adds messages for empty lists\n- Check if list_all_vulnerabilities does anything special for empty results\n\nPattern should be:\n1. Get empty list from API (safeAttacks.isEmpty())\n2. Let PaginationHandler wrap it consistently\n3. PaginationHandler should add message like \"No attacks found\" or respect warnings\n\nMight just work automatically once warnings are passed (from other bead), but verify:\n- Does PaginationHandler add \"No items found\" automatically?\n- Should we distinguish \"no attacks exist\" vs \"filtered out all attacks\"?\n- Do we need special handling for \"ADR not enabled\" scenario?\n\nCheck if there's any special empty-result logic in list_all_vulnerabilities that needs to be replicated.","acceptance_criteria":"- Empty attack results communicated to AI via response message field\n- Behavior consistent with list_all_vulnerabilities empty result handling\n- Distinguish between \"no attacks\" vs \"filtered out\" vs \"ADR not enabled\" if applicable\n- Debug logging kept but response message is primary communication channel\n- Tests added verifying empty result messages\n- Documentation explains when each empty scenario occurs","notes":"Implementation complete. Empty result handling is now standardized between get_attacks and list_all_vulnerabilities:\n\n**What was done:**\n1. Removed redundant debug logging from ADRService.java (lines 217-219) - PaginationHandler already handles empty result messaging\n2. Updated ADRServiceTest.testGetAttacks_EmptyResults_ReturnsEmptyList to assert the \"No items found.\" message is present\n3. Added AssessServiceTest.testGetAllVulnerabilities_EmptyResults_PassesEmptyListToPaginationHandler to verify empty result messaging for list_all_vulnerabilities\n\n**Result:**\nBoth methods now consistently use PaginationHandler.wrapApiPaginatedItems() which automatically adds \"No items found.\" for empty page 1 results. Tests verify this behavior.\n\nAll 217 tests pass.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-31T11:18:57.118594-04:00","updated_at":"2025-10-31T11:18:57.118594-04:00","closed_at":"2025-10-31T00:34:34.087742-04:00"}
{"id":"mcp-47","content_hash":"791c36219b81c16a876fa4f57cfdb0afb799a81c418b697b01f7dc5802dc8cc5","title":"Add @ToolParam annotations to all MCP tool methods for better AI model understanding","description":"Spring AI recommends using @ToolParam annotations to provide parameter-level descriptions in tool schemas. Currently our tools rely only on the description field in @Tool annotation, which provides method-level documentation but doesn't give AI models explicit parameter schemas.\n\n## Current State\n\nTool methods have comprehensive @Tool descriptions but no @ToolParam annotations:\n```java\n@Tool(name = \"list_all_vulnerabilities\", description = \"... lengthy description ...\")\npublic PaginatedResponse\u0026lt;VulnLight\u0026gt; getAllVulnerabilities(\n    Integer page,              // No parameter description\n    Integer pageSize,          // No parameter description  \n    String severities,         // No parameter description\n    String statuses,           // No parameter description\n    // ... 10 parameters total, none annotated\n)\n```\n\n## Benefits of @ToolParam\n\n1. **Explicit parameter schemas** - AI models see each parameter's purpose/format\n2. **Required vs optional** - Mark parameters with `required = false`\n3. **Better tool discovery** - AI understands what values to pass\n4. **Framework alignment** - Follows Spring AI conventions\n\n## Files to Update\n\nServices with @Tool methods:\n- AssessService.java (11+ tool methods)\n- ADRService.java (3 tool methods)\n- SastService.java (tool methods if any)\n- SCAService.java (tool methods if any)\n- RouteCoverageService.java (tool methods if any)\n- PromptService.java (tool methods if any)\n\n## Example Transformation\n\nBefore:\n```java\n@Tool(name = \"list_all_vulnerabilities\", description = \"...\")\npublic PaginatedResponse\u0026lt;VulnLight\u0026gt; getAllVulnerabilities(\n    Integer page,\n    Integer pageSize,\n    String severities\n)\n```\n\nAfter:\n```java\n@Tool(name = \"list_all_vulnerabilities\", description = \"...\")\npublic PaginatedResponse\u0026lt;VulnLight\u0026gt; getAllVulnerabilities(\n    @ToolParam(description = \"Page number (1-based), default: 1\", required = false) \n    Integer page,\n    \n    @ToolParam(description = \"Page size (max 100), default: 50\", required = false) \n    Integer pageSize,\n    \n    @ToolParam(description = \"Comma-separated severities: CRITICAL,HIGH,MEDIUM,LOW,NOTE\", required = false) \n    String severities\n)\n```\n\n## Guidelines\n\n- Extract parameter docs from existing @Tool description field\n- Mark all optional parameters with `required = false`\n- Keep descriptions concise (1-2 lines per parameter)\n- Include valid values/formats in description\n- Include defaults where applicable","design":"Systematic approach to ensure consistency:\n\n1. **Audit phase**: Find all @Tool methods across codebase\n   ```bash\n   grep -r \"@Tool\" src/main/java --include=\"*.java\"\n   ```\n\n2. **Template for each parameter type**:\n   - Pagination params:\n     * page: `@ToolParam(description = \"Page number (1-based), default: 1\", required = false)`\n     * pageSize: `@ToolParam(description = \"Items per page (max 100), default: 50\", required = false)`\n   \n   - Filter params (always optional):\n     * `@ToolParam(description = \"...\", required = false)`\n   \n   - Required params (IDs, names):\n     * `@ToolParam(description = \"...\")` (omit required = false)\n   \n3. **Extract descriptions from existing @Tool.description**:\n   - Parse parameter descriptions from tool-level docs\n   - Condense into concise @ToolParam descriptions\n   - Remove from @Tool description to avoid duplication\n\n4. **Consistency rules**:\n   - All pagination params use same descriptions\n   - Filter params reference valid values/formats\n   - Include examples in description for complex formats (dates, CSV lists)\n   - Mention defaults explicitly\n\n5. **Import statement needed**:\n   ```java\n   import org.springframework.ai.tool.annotation.ToolParam;\n   ```\n\n6. **Order of updates**:\n   - Start with AssessService (most tools)\n   - Then ADRService  \n   - Then other services\n   - Verify compilation after each service","acceptance_criteria":"- All @Tool methods have @ToolParam annotations on every parameter\n- Required vs optional clearly marked with required attribute\n- Parameter descriptions concise and informative\n- Valid values/formats documented in descriptions\n- Defaults mentioned where applicable\n- Import statements added to all affected files\n- Code compiles successfully\n- No duplication between @Tool and @ToolParam descriptions\n- Consistent terminology across all tools","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.119317-04:00","updated_at":"2025-10-31T11:18:57.119317-04:00","closed_at":"2025-10-31T00:58:40.529323-04:00"}
{"id":"mcp-48","content_hash":"1be689174d2dad07eedbf2dc7c18aa41a2a857ec60a255ca91c75dc4ccbafb2a","title":"Implement Spring AI exception pattern: throw ToolExecutionException for hard errors, return messages for context","description":"Spring AI recommends throwing ToolExecutionException for tool-specific errors so error messages reach the AI model. Currently we throw IOException (checked exception), which may not be communicated back to the model correctly.\n\n## Current State\n\nTool methods declare `throws IOException` and throw it for errors:\n```java\n@Tool(name = \"list_all_vulnerabilities\", description = \"...\")\npublic PaginatedResponse\u0026lt;VulnLight\u0026gt; getAllVulnerabilities(...) throws IOException {\n    try {\n        // ...\n    } catch (Exception e) {\n        throw new IOException(\"Failed to list vulnerabilities: \" + e.getMessage(), e);\n    }\n}\n```\n\n## Spring AI Pattern\n\n```java\n@Tool(name = \"list_all_vulnerabilities\", description = \"...\")\npublic PaginatedResponse\u0026lt;VulnLight\u0026gt; getAllVulnerabilities(...) {\n    try {\n        // ...\n    } catch (Exception e) {\n        throw new ToolExecutionException(\"Failed to list vulnerabilities: \" + e.getMessage(), e);\n    }\n}\n```\n\n## Key Changes\n\n1. **Remove `throws IOException`** from method signatures\n2. **Replace `throw new IOException(...)`** with `throw new ToolExecutionException(...)`\n3. **Add import**: `org.springframework.ai.tool.ToolExecutionException`\n\n## Impact\n\n- Runtime exception messages are sent back to AI model\n- AI gets descriptive error feedback for self-correction\n- Aligns with Spring AI conventions\n- Removes checked exception burden from callers\n\n## Scope\n\nAll service classes with @Tool methods:\n- AssessService.java\n- ADRService.java  \n- SastService.java\n- SCAService.java\n- RouteCoverageService.java\n- PromptService.java\n\n## Note on Validation Errors\n\nThis bead addresses SYSTEM/RUNTIME errors only. Validation errors (invalid parameters) should continue using PaginatedResponse.error() pattern for structured feedback. We'll discuss that pattern separately (issue #3 from analysis).\n\nSystem errors = SDK failures, network issues, unexpected exceptions\nValidation errors = bad input parameters (handled via PaginatedResponse.error())","design":"Strategy:\n\n1. **Two exception patterns**:\n   - **Validation errors** ‚Üí PaginatedResponse.error() (keep as-is)\n   - **System/runtime errors** ‚Üí ToolExecutionException (new)\n\n2. **Identify system errors**:\n   - SDK API call failures\n   - Network/connection issues\n   - Unexpected exceptions from dependencies\n   - null responses when data expected\n   - General catch-all exceptions\n\n3. **Update pattern**:\n   ```java\n   // Validation errors (KEEP THIS PATTERN):\n   if (!filters.isValid()) {\n       return PaginatedResponse.error(page, pageSize, errorMessage);\n   }\n   \n   // System/runtime errors (CHANGE THIS):\n   try {\n       // SDK calls, business logic\n   } catch (Exception e) {\n       throw new ToolExecutionException(\"Failed to X: \" + e.getMessage(), e);\n   }\n   ```\n\n4. **Method signature changes**:\n   - Remove `throws IOException` from all @Tool method signatures\n   - ToolExecutionException is RuntimeException (unchecked)\n\n5. **Error message quality**:\n   - Keep descriptive messages\n   - Include context about what operation failed\n   - Preserve cause exception for stack traces\n\n6. **Import updates**:\n   ```java\n   // Remove (if not used elsewhere):\n   import java.io.IOException;\n   \n   // Add:\n   import org.springframework.ai.tool.ToolExecutionException;\n   ```\n\n7. **Testing considerations**:\n   - Update tests expecting IOException\n   - Verify exception messages reach AI model in integration tests","acceptance_criteria":"- All @Tool methods no longer declare throws IOException\n- System/runtime errors throw ToolExecutionException instead\n- Validation errors still use PaginatedResponse.error() pattern (unchanged)\n- Import statements updated in all affected files\n- Error messages remain descriptive and contextual\n- Cause exceptions preserved in ToolExecutionException constructor\n- Code compiles successfully\n- Tests updated to expect ToolExecutionException where appropriate\n- Clear distinction between validation errors (response) vs system errors (exception)","notes":"EXPANDED SCOPE after discussion:\n\nKey insight: \"warnings\" is wrong terminology - they're conversational context messages, not failures.\n\n## Two Communication Channels\n\n1. **Hard errors (stop execution)** ‚Üí throw ToolExecutionException\n   - Invalid enum values\n   - Unparseable dates  \n   - Invalid date ranges\n   - SDK/network failures\n\n2. **Informational messages (execution continues)** ‚Üí response.message\n   - Smart defaults applied\n   - Corrected values (page size capped)\n   - Interpretation notes\n   - Empty result context\n\n## Full Scope\n\n1. **Filter classes**: Rename \"warnings\" ‚Üí \"messages\"\n   - VulnerabilityFilterParams\n   - AttackFilterParams (mcp-45)\n\n2. **PaginatedResponse**: Remove error() factory method\n\n3. **PaginationHandler**: Accept \"messages\" not \"warnings\"\n\n4. **All @Tool methods**:\n   - Remove throws IOException\n   - Hard validation errors ‚Üí throw ToolExecutionException\n   - System errors ‚Üí throw ToolExecutionException\n   - Informational context ‚Üí return in response.message\n\n5. **Pattern**:\n```java\n// Validate\nVulnerabilityFilterParams filters = VulnerabilityFilterParams.of(...);\n\n// Hard errors stop execution\nif (!filters.isValid()) {\n    throw new ToolExecutionException(String.join(\"; \", filters.errors()));\n}\n\n// Execute\ntry {\n    // SDK calls\n} catch (Exception e) {\n    throw new ToolExecutionException(\"Failed: \" + e.getMessage(), e);\n}\n\n// Return with informational messages\nreturn paginationHandler.wrapApiPaginatedItems(vulns, pagination, total, filters.messages());\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.120208-04:00","updated_at":"2025-10-31T11:18:57.120208-04:00","closed_at":"2025-10-21T11:54:45.287269-04:00"}
{"id":"mcp-49","content_hash":"601be3cfae943f1450411531645d3cb8d712123b396911d0e520bfda56891aeb","title":"Integration tests for environments and tags validation","description":"Create integration tests that call real TeamServer API to verify that environments and tags fields are properly populated in vulnerability responses.\n\nCurrent state:\n- Integration test infrastructure is set up using Maven Failsafe plugin\n- EnvironmentsIT.java created with Spring Boot test context\n- Environment variable configuration working (.env.integration-test)\n- Test attempts to connect to real TeamServer but getting 401 Unauthorized\n\nWhat's needed:\n- Fix authentication issue (verify credentials)\n- Run integration test successfully against TeamServer\n- Verify environments field is populated from server_environments\n- Verify tags field is populated from trace tags\n- Document results in bead\n- Set up GitHub Actions workflow to run integration tests in CI\n\nFiles created:\n- src/test/java/com/contrast/labs/ai/mcp/contrast/EnvironmentsIT.java\n- .env.integration-test.template\n- .env.integration-test (gitignored)\n- INTEGRATION_TESTS.md\n- Updated pom.xml with failsafe plugin\n\nRelated: mcp-25, mcp-28","design":"Maven Failsafe approach (canonical Java way):\n\n1. Integration tests in src/test/java with *IT.java suffix\n2. Maven Failsafe plugin runs during verify phase\n3. Tests use @SpringBootTest to load full application context\n4. Environment variables passed via .env.integration-test (not committed)\n5. Tests only run if CONTRAST_HOST_NAME is set (@EnabledIfEnvironmentVariable)\n\nTest implementation:\n- EnvironmentsIT.testEnvironmentsAndTagsArePopulated() - verifies fields present\n- EnvironmentsIT.testVulnerabilitiesHaveBasicFields() - verifies basic functionality\n- Uses @Autowired AssessService (real instance, not mocked)\n- Makes actual API calls to TeamServer\n\nRunning tests:\n- Local: source .env.integration-test \u0026\u0026 mvn verify\n- Skip: mvn verify -DskipITs\n- CI: Set environment variables as secrets in GitHub Actions","acceptance_criteria":"- EnvironmentsIT.java compiles and runs\n- Tests connect to real TeamServer successfully\n- Tests verify environments field is populated (not empty when data exists)\n- Tests verify tags field is populated (not empty when data exists)\n- Tests pass with valid credentials\n- Documentation in INTEGRATION_TESTS.md is complete\n- GitHub Actions workflow configured (optional)\n- Integration tests can be run locally with: mvn verify\n- Integration tests can be skipped with: mvn verify -DskipITs","notes":"Integration test results - environments field issue identified:\n\n‚úÖ Test infrastructure working:\n- Integration tests run successfully\n- Spring Boot context loads correctly\n- Connects to real TeamServer\n\n‚úÖ Tags working:\n- 2/10 vulnerabilities have tags populated\n- SDK getTags() method works correctly\n- Example: [has, tag1], [cross-site, untrusted]\n\n‚ùå Environments NOT working:\n- 0/10 vulnerabilities have environments (all return empty list [])\n- SDK getServerEnvironments() returns empty for all vulnerabilities\n- expand=server_environments parameter is being sent in API calls\n\nRoot cause investigation:\n- SDK 3.4.4 has getServerEnvironments() method ‚úì\n- Code properly calls trace.getServerEnvironments() ‚úì\n- expand parameter added to API calls ‚úì\n- BUT: TeamServer teamserver-staging.contsec.com may not support server_environments field yet\n\nNext steps:\n1. Verify TeamServer version and API support for server_environments\n2. Check if feature flag needed on TeamServer\n3. May need to fall back to expand=servers approach temporarily\n4. Or wait for TeamServer deployment with server_environments support","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.121308-04:00","updated_at":"2025-10-31T11:18:57.121308-04:00","closed_at":"2025-10-30T22:26:43.584153-04:00","dependencies":[{"issue_id":"mcp-49","depends_on_id":"mcp-25","type":"related","created_at":"2025-10-31T11:18:57.151272-04:00","created_by":"auto-import"},{"issue_id":"mcp-49","depends_on_id":"mcp-28","type":"related","created_at":"2025-10-31T11:18:57.152343-04:00","created_by":"auto-import"}]}
{"id":"mcp-5","content_hash":"bbacad56d825674127ed4e99b393b84c2852392371965844782517166c00ebc0","title":"Fix null safety in AttackSummary","description":"In AttackSummary.java:51, attack.getAttacksApplication() may return null causing NPE. Add null guard: Optional.ofNullable(attack.getAttacksApplication()).orElse(List.of()) before streaming.\n\nFlagged by: Copilot in PR #21","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-31T11:18:57.122625-04:00","updated_at":"2025-10-31T11:18:57.122625-04:00","closed_at":"2025-10-16T22:17:52.386323-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-50","content_hash":"6a77df8bb9c806bf4b25b3950a81a195c11b4614cbc078ee58eed226d16c63c9","title":"Configure Contrast credentials in GitHub Actions and run integration tests","description":"Set up GitHub Actions secrets for Contrast credentials and configure CI workflow to run AssessServiceIntegrationTest against real TeamServer. This will validate that the integration tests work in the CI environment.","design":"1. Add GitHub Actions secrets for Contrast credentials:\n   - CONTRAST_HOST_NAME\n   - CONTRAST_API_KEY\n   - CONTRAST_SERVICE_KEY\n   - CONTRAST_USERNAME\n   - CONTRAST_ORG_ID\n\n2. Update or create GitHub Actions workflow to:\n   - Run `mvn verify` with environment variables set from secrets\n   - Ensure integration tests execute (not skipped)\n   - Report test results\n\n3. Verify integration test execution in CI:\n   - Check that AssessServiceIntegrationTest runs successfully\n   - Confirm tests are not skipped due to missing credentials\n   - Validate test output shows real vulnerability data retrieval","acceptance_criteria":"- GitHub repository has all 5 Contrast credential secrets configured\n- CI workflow runs integration tests with credentials\n- AssessServiceIntegrationTest executes successfully in CI (not skipped)\n- CI build log shows \"Tests run: 2, Failures: 0, Errors: 0, Skipped: 0\" for AssessServiceIntegrationTest\n- Integration tests retrieve real data from TeamServer in CI environment","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-31T11:18:57.124775-04:00","updated_at":"2025-10-31T11:18:57.124775-04:00"}
{"id":"mcp-51","content_hash":"d39744edeb411c752c6738e9b32e81de46b6b3e361bffae7e25d452cbdf3c7d9","title":"Remove unused AttacksResponse.Links class","description":"The AttacksResponse.Links inner class and its associated field/methods are never used in the codebase. ADRService only uses getAttacks() and getTotalCount() from AttacksResponse. The Links class was added to match the API response structure but pagination is handled via PaginationHandler with offset/limit, not HATEOAS-style links.\n\nCode to remove:\n- Links inner class (lines 33-70)\n- links field (line 28)\n- getLinks() and setLinks() methods (lines 106-112)\n\nBenefits:\n- Reduces code complexity\n- Removes dead code\n- Clarifies that pagination uses count-based approach, not link-based","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-10-31T11:18:57.125851-04:00","updated_at":"2025-10-31T11:18:57.125851-04:00","closed_at":"2025-10-31T01:16:01.219369-04:00"}
{"id":"mcp-52","content_hash":"c380f2cd4b9123e5755af35b261f449db1c7660bf9a4bdf731e68d25c2356c5f","title":"Remove unused paginateInMemory methods and rename wrapApiPaginatedItems","description":"The paginateInMemory() methods in PaginationHandler are no longer used in production code. The codebase now uses API-level pagination (passing limit/offset to the API) instead of fetching all items and paginating in memory.\n\n## Current Usage\n- ADRService: uses wrapApiPaginatedItems()\n- AssessService: uses wrapApiPaginatedItems()  \n- No production code uses paginateInMemory()\n\n## Changes Needed\n\n1. **Remove dead code:**\n   - paginateInMemory(List\u003cT\u003e, PaginationParams) - lines 99-104\n   - paginateInMemory(List\u003cT\u003e, PaginationParams, List\u003cString\u003e) - lines 116-147\n   - Related test methods in PaginationHandlerTest.java (9 test methods)\n\n2. **Rename for clarity:**\n   - Rename wrapApiPaginatedItems() to buildResponse() or toResponse()\n   - Now that it's the only pagination method, the name doesn't need to distinguish \"API-paginated\" vs \"in-memory\"\n   - Update all call sites in ADRService and AssessService\n   - Update tests\n\n## Benefits\n- Removes ~50 lines of dead code\n- Clarifies that API-level pagination is the only approach\n- Simpler, clearer method name\n- Reduces test surface area","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-10-31T11:18:57.12654-04:00","updated_at":"2025-10-31T11:18:57.12654-04:00","closed_at":"2025-10-31T01:37:29.029797-04:00"}
{"id":"mcp-53","content_hash":"29ffe784fe0f7bd459fe7d7aae79b2ae74bd50a23de1b3764d272316a9cca9b1","title":"Add Lombok to reduce boilerplate in new vulnerability reporting classes","description":"Refactor the classes added in the new-vuln-reporting-feature branch to use Lombok annotations, reducing ~554 lines of boilerplate code (77% reduction in data classes).\n\nTarget classes for Lombok conversion:\n- Attack.java (310 ‚Üí 60 lines, -250 lines with @Getter @Setter)\n- AttacksFilterBody.java (207 ‚Üí 35 lines, -172 lines with @Value @Builder)\n- AttacksResponse.java (74 ‚Üí 25 lines, -49 lines with @Getter @Setter)\n- VulnerabilityContext.java (71 ‚Üí 10 lines, -61 lines with @Value @Builder, remove manual builder)\n\nNote: Records (AttackSummary, PaginatedResponse, etc.) are already concise and don't need Lombok.\n\nThis change will:\n- Eliminate manual getters/setters\n- Replace manual builder pattern with @Builder\n- Improve maintainability\n- Reduce visual clutter","design":"1. Add Lombok dependency to pom.xml (scope: provided)\n2. Convert Attack.java: Add @Getter @Setter, remove all getter/setter methods\n3. Convert AttacksFilterBody.java: Replace manual Builder with @Value @Builder, use @Builder.Default for defaults\n4. Convert AttacksResponse.java: Add @Getter @Setter, keep getTotalCount() method\n5. Convert VulnerabilityContext.java: Replace record + manual builder with @Value @Builder\n6. Run tests to ensure no behavioral changes\n7. Verify IDE can see generated methods (may need Lombok plugin)\n8. Update CLAUDE.md if needed to mention Lombok usage","acceptance_criteria":"- All 4 target classes use Lombok annotations\n- All existing tests pass without modification\n- Code compiles and runs successfully\n- Total line reduction of ~500+ lines achieved\n- Lombok dependency added to pom.xml\n- Generated code functions identically to manual code","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-10-31T11:18:57.127122-04:00","updated_at":"2025-10-31T12:06:32.901951-04:00","closed_at":"2025-10-31T12:06:32.901951-04:00"}
{"id":"mcp-54","content_hash":"99d4d5cb15b6082ab8ec2892fefbda830fa8b68a56775beaa2b9ed4f41255395","title":"Extend Lombok usage to entire project codebase","description":"After successfully introducing Lombok to the new vulnerability reporting classes, extend Lombok annotations throughout the entire MCP Contrast codebase to reduce boilerplate.\n\nAudit and convert all eligible classes project-wide:\n- SDK extension data classes (Application, LibraryExtended, TraceExtended, etc.)\n- Existing data models (StackLib, ApplicationData, etc.)\n- Service classes that could benefit from @Slf4j\n- Any other POJOs with manual getters/setters/builders\n\nThis is a larger refactoring that should be done after the initial Lombok introduction proves successful.","design":"1. Audit entire src/main/java directory for boilerplate code\n2. Identify all classes with manual getters/setters\n3. Identify all classes with manual builder patterns\n4. Create prioritized conversion list (high-boilerplate classes first)\n5. Convert classes incrementally with test verification\n6. Consider @Slf4j for logger reduction in service classes\n7. Update documentation about Lombok usage patterns\n8. Consider adding Lombok configuration file (lombok.config) for team standards","acceptance_criteria":"- All eligible classes project-wide use appropriate Lombok annotations\n- All tests pass\n- Code coverage maintained or improved\n- Documentation updated with Lombok patterns\n- lombok.config file added if needed for consistency\n- Significant overall line count reduction achieved","status":"open","priority":3,"issue_type":"chore","created_at":"2025-10-31T11:18:57.127747-04:00","updated_at":"2025-10-31T11:18:57.127747-04:00","dependencies":[{"issue_id":"mcp-54","depends_on_id":"mcp-53","type":"blocks","created_at":"2025-10-31T11:19:42.329222-04:00","created_by":"chrisedwards"}]}
{"id":"mcp-55","content_hash":"a475e1f9e16da32ef279ec00b1632023a65b08cf058cecd9b37540b4f7048e91","title":"Replace Date.toString() with FilterHelper.formatTimestamp() in AttackSummary","description":"AttackSummary.java uses Date.toString() for timestamp formatting instead of the standardized FilterHelper.formatTimestamp() used throughout the rest of the codebase. This creates inconsistent output formats.\n\nCurrent behavior (AttackSummary.java:62-67, 96-97):\n- Uses: new Date(attack.getStart_time()).toString()\n- Produces: \"Thu Jan 15 10:30:00 EST 2025\" (locale-dependent)\n\nExpected behavior:\n- Use: FilterHelper.formatTimestamp(attack.getStart_time())\n- Produces: \"2025-01-15T10:30:00-05:00\" (ISO 8601, consistent)\n\nThis breaks the consistent ISO 8601 formatting standard established in:\n- VulnLight timestamps\n- ApplicationData timestamps  \n- All other MCP tool responses\n\nImpact: AI agents and downstream systems expect consistent ISO 8601 format with timezone offsets.","design":"1. Open src/main/java/com/contrast/labs/ai/mcp/contrast/data/AttackSummary.java\n2. In fromAttack() method around line 62-69, replace:\n   - new Date(attack.getStart_time()).toString() ‚Üí FilterHelper.formatTimestamp(attack.getStart_time())\n   - new Date(attack.getEnd_time()).toString() ‚Üí FilterHelper.formatTimestamp(attack.getEnd_time())\n   - new Date(attack.getFirst_event_time()).toString() ‚Üí FilterHelper.formatTimestamp(attack.getFirst_event_time())\n   - new Date(attack.getLast_event_time()).toString() ‚Üí FilterHelper.formatTimestamp(attack.getLast_event_time())\n3. In ApplicationAttackInfo.fromAttackApplication() method around line 96-97, replace:\n   - new Date(attackApp.getStartTime()).toString() ‚Üí FilterHelper.formatTimestamp(attackApp.getStartTime())\n   - new Date(attackApp.getEndTime()).toString() ‚Üí FilterHelper.formatTimestamp(attackApp.getEndTime())\n4. Remove unused import: java.util.Date\n5. Ensure FilterHelper import exists: import com.contrast.labs.ai.mcp.contrast.FilterHelper;\n6. Run tests to verify format change doesn't break anything\n7. Manually verify output format is ISO 8601","acceptance_criteria":"- All 6 Date.toString() calls replaced with FilterHelper.formatTimestamp()\n- java.util.Date import removed if no longer needed\n- All tests pass (unit and integration)\n- Manual testing confirms timestamps are in ISO 8601 format: \"2025-01-15T10:30:00-05:00\"\n- Output format matches other MCP tool timestamp formats (VulnLight, ApplicationData, etc.)\n- No behavioral changes except timestamp format standardization","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-31T11:18:57.128516-04:00","updated_at":"2025-10-31T11:18:57.128516-04:00","closed_at":"2025-10-31T11:12:40.611188-04:00"}
{"id":"mcp-6","content_hash":"79591e810b3d56d971e85ba968e3d6b324f419cb1fa4cddce5fa1676230dc05f","title":"Replace Object types with concrete types in Attack.java","description":"In Attack.java lines 32, 43, 46, replace Object types with concrete types (String or other strong types). This improves type safety and prevents unchecked casts. Specifically: attacker field (line 32) and user_agents field (line 46).\n\nFlagged by: ChrisEdwards and Copilot in PR #21","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-10-31T11:18:57.129493-04:00","updated_at":"2025-10-31T11:18:57.129493-04:00","closed_at":"2025-10-16T21:48:29.641095-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-7","content_hash":"591181ef50a8e3fbc3d6bf54c71ee2ff124ad27d88cae7cc99e4d51bad4ad5e0","title":"Fix charset specification in SDKExtension","description":"In SDKExtension.java:388, specify charset explicitly to avoid platform default differences. Change to: new InputStreamReader(is, StandardCharsets.UTF_8)\n\nFlagged by: Copilot and JacobMagesHaskinsContrast in PR #21","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-10-31T11:18:57.130169-04:00","updated_at":"2025-10-31T11:18:57.130169-04:00","closed_at":"2025-10-16T21:42:55.644994-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-8","content_hash":"89e5e667de5a67fa37de1594b95f7c05d6385aab05335ed70af92a0194236548","title":"Fix immutable list initialization in AttacksFilterBody","description":"In AttacksFilterBody.java:49, returning unmodifiable empty lists (List.of()) while exposing setters may surprise callers. Initialize with new ArrayList\u003c\u003e() to allow in-place modification.\n\nFlagged by: Copilot in PR #21","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-10-31T11:18:57.130737-04:00","updated_at":"2025-10-31T11:18:57.130737-04:00","closed_at":"2025-10-16T21:39:11.231167-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
{"id":"mcp-9","content_hash":"a3fff85d6e7585a1ff81ecc1262b8658dd283e5c60fb11c1d4794433c39889b3","title":"Remove unused JsonElement import","description":"In SDKExtension.java:40, remove unused JsonElement import to reduce noise.\n\nFlagged by: Copilot and JacobMagesHaskinsContrast in PR #21","status":"closed","priority":3,"issue_type":"chore","created_at":"2025-10-31T11:18:57.131361-04:00","updated_at":"2025-10-31T11:18:57.131361-04:00","closed_at":"2025-10-16T21:17:43.351557-04:00","external_ref":"https://github.com/Contrast-Security-OSS/mcp-contrast/pull/21"}
